import { _registerComponent as F, registerVersion as D, getApp as V, _getProvider as x, SDK_VERSION as M } from "../../app/dist/esm/index.esm2017.jsx";
import { Component as $ } from "../../component/dist/esm/index.esm2017.jsx";
import { LogLevel as P, Logger as B } from "../../logger/dist/esm/index.esm2017.jsx";
import { FirebaseError as j, getDefaultEmulatorHostnameAndPort as q, createMockUserToken as z } from "../../util/dist/index.esm2017.jsx";
import { Integer as G } from "../../webchannel-wrapper/dist/esm/index.esm2017.jsx";
const y = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class u {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
u.UNAUTHENTICATED = new u(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
u.GOOGLE_CREDENTIALS = new u("google-credentials-uid"), u.FIRST_PARTY = new u("first-party-uid"), u.MOCK_USER = new u("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let A = "10.7.2";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const f = new B("@firebase/firestore");
function p(i, ...e) {
  if (f.logLevel <= P.DEBUG) {
    const t = e.map(R);
    f.debug(`Firestore (${A}): ${i}`, ...t);
  }
}
function N(i, ...e) {
  if (f.logLevel <= P.ERROR) {
    const t = e.map(R);
    f.error(`Firestore (${A}): ${i}`, ...t);
  }
}
function K(i, ...e) {
  if (f.logLevel <= P.WARN) {
    const t = e.map(R);
    f.warn(`Firestore (${A}): ${i}`, ...t);
  }
}
function R(i) {
  if (typeof i == "string")
    return i;
  try {
    /**
    * @license
    * Copyright 2020 Google LLC
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    return function(t) {
      return JSON.stringify(t);
    }(i);
  } catch {
    return i;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function C(i = "Unexpected state") {
  const e = `FIRESTORE (${A}) INTERNAL ASSERTION FAILED: ` + i;
  throw N(e), new Error(e);
}
function T(i, e) {
  i || C();
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const c = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller can not be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
class d extends j {
  /** @hideconstructor */
  constructor(e, t) {
    super(e, t), this.code = e, this.message = t, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class g {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class S {
  constructor(e, t) {
    this.user = t, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${e}`);
  }
}
class H {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
    e.enqueueRetryable(() => t(u.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class X {
  constructor(e) {
    this.token = e, /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(e, t) {
    this.changeListener = t, // Fire with initial user.
    e.enqueueRetryable(() => t(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class Q {
  constructor(e) {
    this.t = e, /** Tracks the current User. */
    this.currentUser = u.UNAUTHENTICATED, /**
     * Counter used to detect if the token changed while a getToken request was
     * outstanding.
     */
    this.i = 0, this.forceRefresh = !1, this.auth = null;
  }
  start(e, t) {
    let s = this.i;
    const o = (l) => this.i !== s ? (s = this.i, t(l)) : Promise.resolve();
    let n = new g();
    this.o = () => {
      this.i++, this.currentUser = this.u(), n.resolve(), n = new g(), e.enqueueRetryable(() => o(this.currentUser));
    };
    const a = () => {
      const l = n;
      e.enqueueRetryable(async () => {
        await l.promise, await o(this.currentUser);
      });
    }, h = (l) => {
      p("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = l, this.auth.addAuthTokenListener(this.o), a();
    };
    this.t.onInit((l) => h(l)), // Our users can initialize Auth right after Firestore, so we give it
    // a chance to register itself with the component framework before we
    // determine whether to start up in unauthenticated mode.
    setTimeout(() => {
      if (!this.auth) {
        const l = this.t.getImmediate({
          optional: !0
        });
        l ? h(l) : (
          // If auth is still not available, proceed with `null` user
          (p("FirebaseAuthCredentialsProvider", "Auth not yet detected"), n.resolve(), n = new g())
        );
      }
    }, 0), a();
  }
  getToken() {
    const e = this.i, t = this.forceRefresh;
    return this.forceRefresh = !1, this.auth ? this.auth.getToken(t).then((s) => (
      // Cancel the request since the token changed while the request was
      // outstanding so the response is potentially for a previous user (which
      // user, we can't be sure).
      this.i !== e ? (p("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : s ? (T(typeof s.accessToken == "string"), new S(s.accessToken, this.currentUser)) : null
    )) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  // Auth.getUid() can return null even with a user logged in. It is because
  // getUid() is synchronous, but the auth code populating Uid is asynchronous.
  // This method should only be called in the AuthTokenListener callback
  // to guarantee to get the actual user.
  u() {
    const e = this.auth && this.auth.getUid();
    return T(e === null || typeof e == "string"), new u(e);
  }
}
class W {
  constructor(e, t, s) {
    this.l = e, this.h = t, this.P = s, this.type = "FirstParty", this.user = u.FIRST_PARTY, this.I = /* @__PURE__ */ new Map();
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  T() {
    return this.P ? this.P() : null;
  }
  get headers() {
    this.I.set("X-Goog-AuthUser", this.l);
    const e = this.T();
    return e && this.I.set("Authorization", e), this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h), this.I;
  }
}
class Y {
  constructor(e, t, s) {
    this.l = e, this.h = t, this.P = s;
  }
  getToken() {
    return Promise.resolve(new W(this.l, this.h, this.P));
  }
  start(e, t) {
    e.enqueueRetryable(() => t(u.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class J {
  constructor(e) {
    this.value = e, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class Z {
  constructor(e) {
    this.A = e, this.forceRefresh = !1, this.appCheck = null, this.R = null;
  }
  start(e, t) {
    const s = (n) => {
      n.error != null && p("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${n.error.message}`);
      const a = n.token !== this.R;
      return this.R = n.token, p("FirebaseAppCheckTokenProvider", `Received ${a ? "new" : "existing"} token.`), a ? t(n.token) : Promise.resolve();
    };
    this.o = (n) => {
      e.enqueueRetryable(() => s(n));
    };
    const o = (n) => {
      p("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = n, this.appCheck.addTokenListener(this.o);
    };
    this.A.onInit((n) => o(n)), // Our users can initialize AppCheck after Firestore, so we give it
    // a chance to register itself with the component framework.
    setTimeout(() => {
      if (!this.appCheck) {
        const n = this.A.getImmediate({
          optional: !0
        });
        n ? o(n) : (
          // If AppCheck is still not available, proceed without it.
          p("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
        );
      }
    }, 0);
  }
  getToken() {
    const e = this.forceRefresh;
    return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then((t) => t ? (T(typeof t.token == "string"), this.R = t.token, new J(t.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ee(i) {
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof self < "u" && (self.crypto || self.msCrypto)
  ), t = new Uint8Array(i);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(t);
  else
    for (let s = 0; s < i; s++)
      t[s] = Math.floor(256 * Math.random());
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class te {
  static newId() {
    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = Math.floor(256 / e.length) * e.length;
    let s = "";
    for (; s.length < 20; ) {
      const o = ee(40);
      for (let n = 0; n < o.length; ++n)
        s.length < 20 && o[n] < t && (s += e.charAt(o[n] % e.length));
    }
    return s;
  }
}
function b(i) {
  return i.name === "IndexedDbTransactionError";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ie {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param longPollingOptions Options that configure long-polling.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(e, t, s, o, n, a, h, l, _) {
    this.databaseId = e, this.appId = t, this.persistenceKey = s, this.host = o, this.ssl = n, this.forceLongPolling = a, this.autoDetectLongPolling = h, this.longPollingOptions = l, this.useFetchStreams = _;
  }
}
class E {
  constructor(e, t) {
    this.projectId = e, this.database = t || "(default)";
  }
  static empty() {
    return new E("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(e) {
    return e instanceof E && e.projectId === this.projectId && e.database === this.database;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var v, r;
(r = v || (v = {}))[r.OK = 0] = "OK", r[r.CANCELLED = 1] = "CANCELLED", r[r.UNKNOWN = 2] = "UNKNOWN", r[r.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", r[r.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", r[r.NOT_FOUND = 5] = "NOT_FOUND", r[r.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", r[r.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", r[r.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", r[r.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", r[r.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", r[r.ABORTED = 10] = "ABORTED", r[r.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", r[r.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", r[r.INTERNAL = 13] = "INTERNAL", r[r.UNAVAILABLE = 14] = "UNAVAILABLE", r[r.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
new G([4294967295, 4294967295], 0);
function I() {
  return typeof document < "u" ? document : null;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class se {
  constructor(e, t, s = 1e3, o = 1.5, n = 6e4) {
    this.oi = e, this.timerId = t, this.Mo = s, this.xo = o, this.Oo = n, this.No = 0, this.Bo = null, /** The last backoff attempt, as epoch milliseconds. */
    this.Lo = Date.now(), this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.No = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  ko() {
    this.No = this.Oo;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  qo(e) {
    this.cancel();
    const t = Math.floor(this.No + this.Qo()), s = Math.max(0, Date.now() - this.Lo), o = Math.max(0, t - s);
    o > 0 && p("ExponentialBackoff", `Backing off for ${o} ms (base delay: ${this.No} ms, delay with jitter: ${t} ms, last attempt: ${s} ms ago)`), this.Bo = this.oi.enqueueAfterDelay(this.timerId, o, () => (this.Lo = Date.now(), e())), // Apply backoff factor to determine next delay and ensure it is within
    // bounds.
    this.No *= this.xo, this.No < this.Mo && (this.No = this.Mo), this.No > this.Oo && (this.No = this.Oo);
  }
  Ko() {
    this.Bo !== null && (this.Bo.skipDelay(), this.Bo = null);
  }
  cancel() {
    this.Bo !== null && (this.Bo.cancel(), this.Bo = null);
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  Qo() {
    return (Math.random() - 0.5) * this.No;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class k {
  constructor(e, t, s, o, n) {
    this.asyncQueue = e, this.timerId = t, this.targetTimeMs = s, this.op = o, this.removalCallback = n, this.deferred = new g(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
    // and so we attach a dummy catch callback to avoid
    // 'UnhandledPromiseRejectionWarning' log spam.
    this.deferred.promise.catch((a) => {
    });
  }
  get promise() {
    return this.deferred.promise;
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(e, t, s, o, n) {
    const a = Date.now() + s, h = new k(e, t, a, o, n);
    return h.start(s), h;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(e) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(e) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new d(c.CANCELLED, "Operation cancelled" + (e ? ": " + e : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((e) => this.deferred.resolve(e))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
function ne(i, e) {
  if (N("AsyncQueue", `${e}: ${i}`), b(i))
    return new d(c.UNAVAILABLE, `${e}: ${i}`);
  throw i;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oe {
  constructor(e, t, s, o) {
    this.authCredentials = e, this.appCheckCredentials = t, this.asyncQueue = s, this.databaseInfo = o, this.user = u.UNAUTHENTICATED, this.clientId = te.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(s, async (n) => {
      p("FirestoreClient", "Received user=", n.uid), await this.authCredentialListener(n), this.user = n;
    }), this.appCheckCredentials.start(s, (n) => (p("FirestoreClient", "Received new app check token=", n), this.appCheckCredentialListener(n, this.user)));
  }
  get configuration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(e) {
    this.authCredentialListener = e;
  }
  setAppCheckTokenChangeListener(e) {
    this.appCheckCredentialListener = e;
  }
  /**
   * Checks that the client has not been terminated. Ensures that other methods on //
   * this class cannot be called after the client is terminated. //
   */
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new d(c.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const e = new g();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), // The credentials provider must be terminated after shutting down the
        // RemoteStore as it will prevent the RemoteStore from retrieving auth
        // tokens.
        this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve();
      } catch (t) {
        const s = ne(t, "Failed to shutdown persistence");
        e.reject(s);
      }
    }), e.promise;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function O(i) {
  const e = {};
  return i.timeoutSeconds !== void 0 && (e.timeoutSeconds = i.timeoutSeconds), e;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const w = /* @__PURE__ */ new Map();
function re(i, e, t, s) {
  if (e === !0 && s === !0)
    throw new d(c.INVALID_ARGUMENT, `${i} and ${t} cannot be used together.`);
}
function ae(i) {
  if (i === void 0)
    return "undefined";
  if (i === null)
    return "null";
  if (typeof i == "string")
    return i.length > 20 && (i = `${i.substring(0, 20)}...`), JSON.stringify(i);
  if (typeof i == "number" || typeof i == "boolean")
    return "" + i;
  if (typeof i == "object") {
    if (i instanceof Array)
      return "an array";
    {
      const e = (
        /** try to get the constructor name for an object. */
        function(s) {
          return s.constructor ? s.constructor.name : null;
        }(i)
      );
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof i == "function" ? "a function" : C();
}
function he(i, e) {
  if ("_delegate" in i && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (i = i._delegate), !(i instanceof e)) {
    if (e.name === i.constructor.name)
      throw new d(c.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const t = ae(i);
      throw new d(c.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${t}`);
    }
  }
  return i;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class L {
  constructor(e) {
    var t, s;
    if (e.host === void 0) {
      if (e.ssl !== void 0)
        throw new d(c.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = !0;
    } else
      this.host = e.host, this.ssl = (t = e.ssl) === null || t === void 0 || t;
    if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.localCache = e.localCache, e.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
        throw new d(c.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    re("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : e.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !0 : (
      // For backwards compatibility, coerce the value to boolean even though
      // the TypeScript compiler has narrowed the type to boolean already.
      // noinspection PointlessBooleanExpressionJS
      this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling
    ), this.experimentalLongPollingOptions = O((s = e.experimentalLongPollingOptions) !== null && s !== void 0 ? s : {}), function(n) {
      if (n.timeoutSeconds !== void 0) {
        if (isNaN(n.timeoutSeconds))
          throw new d(c.INVALID_ARGUMENT, `invalid long polling timeout: ${n.timeoutSeconds} (must not be NaN)`);
        if (n.timeoutSeconds < 5)
          throw new d(c.INVALID_ARGUMENT, `invalid long polling timeout: ${n.timeoutSeconds} (minimum allowed value is 5)`);
        if (n.timeoutSeconds > 30)
          throw new d(c.INVALID_ARGUMENT, `invalid long polling timeout: ${n.timeoutSeconds} (maximum allowed value is 30)`);
      }
    }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e.useFetchStreams;
  }
  isEqual(e) {
    return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && function(s, o) {
      return s.timeoutSeconds === o.timeoutSeconds;
    }(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams;
  }
}
class U {
  /** @hideconstructor */
  constructor(e, t, s, o) {
    this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = s, this._app = o, /**
     * Whether it's a Firestore or Firestore Lite instance.
     */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new L({}), this._settingsFrozen = !1;
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app)
      throw new d(c.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(e) {
    if (this._settingsFrozen)
      throw new d(c.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new L(e), e.credentials !== void 0 && (this._authCredentials = function(s) {
      if (!s)
        return new H();
      switch (s.type) {
        case "firstParty":
          return new Y(s.sessionIndex || "0", s.iamToken || null, s.authTokenFactory || null);
        case "provider":
          return s.client;
        default:
          throw new d(c.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = !0, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function(t) {
      const s = w.get(t);
      s && (p("ComponentProvider", "Removing Datastore"), w.delete(t), s.terminate());
    }(this), Promise.resolve();
  }
}
function le(i, e, t, s = {}) {
  var o;
  const n = (i = he(i, U))._getSettings(), a = `${e}:${t}`;
  if (n.host !== "firestore.googleapis.com" && n.host !== a && K("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), i._setSettings(Object.assign(Object.assign({}, n), {
    host: a,
    ssl: !1
  })), s.mockUserToken) {
    let h, l;
    if (typeof s.mockUserToken == "string")
      h = s.mockUserToken, l = u.MOCK_USER;
    else {
      h = z(s.mockUserToken, (o = i._app) === null || o === void 0 ? void 0 : o.options.projectId);
      const _ = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!_)
        throw new d(c.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      l = new u(_);
    }
    i._authCredentials = new X(new S(h, l));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ue {
  constructor() {
    this.Xa = Promise.resolve(), // A list of retryable operations. Retryable operations are run in order and
    // retried with backoff.
    this.eu = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
    // be changed again.
    this.tu = !1, // Operations scheduled to be queued in the future. Operations are
    // automatically removed after they are run or canceled.
    this.nu = [], // visible for testing
    this.ru = null, // Flag set while there's an outstanding AsyncQueue operation, used for
    // assertion sanity-checks.
    this.iu = !1, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
    this.su = !1, // List of TimerIds to fast-forward delays for.
    this.ou = [], // Backoff timer used to schedule retries for retryable operations
    this.jo = new se(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    ), // Visibility handler that triggers an immediate retry of all retryable
    // operations. Meant to speed up recovery when we regain file system access
    // after page comes into foreground.
    this._u = () => {
      const t = I();
      t && p("AsyncQueue", "Visibility state changed to " + t.visibilityState), this.jo.Ko();
    };
    const e = I();
    e && typeof e.addEventListener == "function" && e.addEventListener("visibilitychange", this._u);
  }
  get isShuttingDown() {
    return this.tu;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(e) {
    this.enqueue(e);
  }
  enqueueAndForgetEvenWhileRestricted(e) {
    this.au(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.uu(e);
  }
  enterRestrictedMode(e) {
    if (!this.tu) {
      this.tu = !0, this.su = e || !1;
      const t = I();
      t && typeof t.removeEventListener == "function" && t.removeEventListener("visibilitychange", this._u);
    }
  }
  enqueue(e) {
    if (this.au(), this.tu)
      return new Promise(() => {
      });
    const t = new g();
    return this.uu(() => this.tu && this.su ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise)).then(() => t.promise);
  }
  enqueueRetryable(e) {
    this.enqueueAndForget(() => (this.eu.push(e), this.cu()));
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async cu() {
    if (this.eu.length !== 0) {
      try {
        await this.eu[0](), this.eu.shift(), this.jo.reset();
      } catch (e) {
        if (!b(e))
          throw e;
        p("AsyncQueue", "Operation failed with retryable error: " + e);
      }
      this.eu.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
      // This is necessary to run retryable operations that failed during
      // their initial attempt since we don't know whether they are already
      // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
      // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
      // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
      // call scheduled here.
      // Since `backoffAndRun()` cancels an existing backoff and schedules a
      // new backoff on every call, there is only ever a single additional
      // operation in the queue.
      this.jo.qo(() => this.cu());
    }
  }
  uu(e) {
    const t = this.Xa.then(() => (this.iu = !0, e().catch((s) => {
      this.ru = s, this.iu = !1;
      const o = (
        /**
        * Chrome includes Error.message in Error.stack. Other browsers do not.
        * This returns expected output of message + stack when available.
        * @param error - Error or FirestoreError
        */
        function(a) {
          let h = a.message || "";
          return a.stack && (h = a.stack.includes(a.message) ? a.stack : a.message + `
` + a.stack), h;
        }(s)
      );
      throw N("INTERNAL UNHANDLED ERROR: ", o), s;
    }).then((s) => (this.iu = !1, s))));
    return this.Xa = t, t;
  }
  enqueueAfterDelay(e, t, s) {
    this.au(), // Fast-forward delays for timerIds that have been overriden.
    this.ou.indexOf(e) > -1 && (t = 0);
    const o = k.createAndSchedule(this, e, t, s, (n) => this.lu(n));
    return this.nu.push(o), o;
  }
  au() {
    this.ru && C();
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async hu() {
    let e;
    do
      e = this.Xa, await e;
    while (e !== this.Xa);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  Pu(e) {
    for (const t of this.nu)
      if (t.timerId === e)
        return !0;
    return !1;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  Iu(e) {
    return this.hu().then(() => {
      this.nu.sort((t, s) => t.targetTimeMs - s.targetTimeMs);
      for (const t of this.nu)
        if (t.skipDelay(), e !== "all" && t.timerId === e)
          break;
      return this.hu();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  Tu(e) {
    this.ou.push(e);
  }
  /** Called once a DelayedOperation is run or canceled. */
  lu(e) {
    const t = this.nu.indexOf(e);
    this.nu.splice(t, 1);
  }
}
class ce extends U {
  /** @hideconstructor */
  constructor(e, t, s, o) {
    super(e, t, s, o), /**
     * Whether it's a {@link Firestore} or Firestore Lite instance.
     */
    this.type = "firestore", this._queue = function() {
      return new ue();
    }(), this._persistenceKey = (o == null ? void 0 : o.name) || "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || // The client must be initialized to ensure that all subsequent API
    // usage throws an exception.
    de(this), this._firestoreClient.terminate();
  }
}
function Ae(i, e) {
  const t = typeof i == "object" ? i : V(), s = typeof i == "string" ? i : e || "(default)", o = x(t, "firestore").getImmediate({
    identifier: s
  });
  if (!o._initialized) {
    const n = q("firestore");
    n && le(o, ...n);
  }
  return o;
}
function de(i) {
  var e, t, s;
  const o = i._freezeSettings(), n = function(h, l, _, m) {
    return new ie(h, l, _, m.host, m.ssl, m.experimentalForceLongPolling, m.experimentalAutoDetectLongPolling, O(m.experimentalLongPollingOptions), m.useFetchStreams);
  }(i._databaseId, ((e = i._app) === null || e === void 0 ? void 0 : e.options.appId) || "", i._persistenceKey, o);
  i._firestoreClient = new oe(i._authCredentials, i._appCheckCredentials, i._queue, n), !((t = o.localCache) === null || t === void 0) && t._offlineComponentProvider && (!((s = o.localCache) === null || s === void 0) && s._onlineComponentProvider) && (i._firestoreClient._uninitializedComponentsProvider = {
    _offlineKind: o.localCache.kind,
    _offline: o.localCache._offlineComponentProvider,
    _online: o.localCache._onlineComponentProvider
  });
}
(function(e, t = !0) {
  (function(o) {
    A = o;
  })(M), F(new $("firestore", (s, { instanceIdentifier: o, options: n }) => {
    const a = s.getProvider("app").getImmediate(), h = new ce(new Q(s.getProvider("auth-internal")), new Z(s.getProvider("app-check-internal")), function(_, m) {
      if (!Object.prototype.hasOwnProperty.apply(_.options, ["projectId"]))
        throw new d(c.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new E(_.options.projectId, m);
    }(a, o), a);
    return n = Object.assign({
      useFetchStreams: t
    }, n), h._setSettings(n), h;
  }, "PUBLIC").setMultipleInstances(!0)), D(y, "4.4.1", e), // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
  D(y, "4.4.1", "esm2017");
})();
export {
  ce as Firestore,
  d as FirestoreError,
  te as _AutoId,
  E as _DatabaseId,
  H as _EmptyAuthCredentialsProvider,
  he as _cast,
  K as _logWarn,
  re as _validateIsNotUsedTogether,
  le as connectFirestoreEmulator,
  Ae as getFirestore
};
