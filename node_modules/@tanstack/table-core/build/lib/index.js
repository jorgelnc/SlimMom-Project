/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function E(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function _(e, t) {
  return (n) => {
    t.setState((o) => ({
      ...o,
      [e]: E(n, o[e])
    }));
  };
}
function D(e) {
  return e instanceof Function;
}
function pe(e) {
  return Array.isArray(e) && e.every((t) => typeof t == "number");
}
function ce(e, t) {
  const n = [], o = (r) => {
    r.forEach((i) => {
      n.push(i);
      const l = t(i);
      l != null && l.length && o(l);
    });
  };
  return o(e), n;
}
function S(e, t, n) {
  let o = [], r;
  return () => {
    let i;
    n.key && n.debug && (i = Date.now());
    const l = e();
    if (!(l.length !== o.length || l.some((a, s) => o[s] !== a)))
      return r;
    o = l;
    let g;
    if (n.key && n.debug && (g = Date.now()), r = t(...l), n == null || n.onChange == null || n.onChange(r), n.key && n.debug && n != null && n.debug()) {
      const a = Math.round((Date.now() - i) * 100) / 100, s = Math.round((Date.now() - g) * 100) / 100, d = s / 16, c = (p, f) => {
        for (p = String(p); p.length < f; )
          p = " " + p;
        return p;
      };
      console.info(`%c⏱ ${c(s, 5)} /${c(a, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * d, 120))}deg 100% 31%);`, n == null ? void 0 : n.key);
    }
    return r;
  };
}
function fe(e, t, n, o) {
  var r, i;
  const u = {
    ...e._getDefaultColumnDef(),
    ...t
  }, g = u.accessorKey;
  let a = (r = (i = u.id) != null ? i : g ? g.replace(".", "_") : void 0) != null ? r : typeof u.header == "string" ? u.header : void 0, s;
  if (u.accessorFn ? s = u.accessorFn : g && (g.includes(".") ? s = (c) => {
    let p = c;
    for (const m of g.split(".")) {
      var f;
      p = (f = p) == null ? void 0 : f[m], process.env.NODE_ENV !== "production" && p === void 0 && console.warn(`"${m}" in deeply nested key "${g}" returned undefined.`);
    }
    return p;
  } : s = (c) => c[u.accessorKey]), !a)
    throw process.env.NODE_ENV !== "production" ? new Error(u.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header") : new Error();
  let d = {
    id: `${String(a)}`,
    accessorFn: s,
    parent: o,
    depth: n,
    columnDef: u,
    columns: [],
    getFlatColumns: S(() => [!0], () => {
      var c;
      return [d, ...(c = d.columns) == null ? void 0 : c.flatMap((p) => p.getFlatColumns())];
    }, {
      key: process.env.NODE_ENV === "production" && "column.getFlatColumns",
      debug: () => {
        var c;
        return (c = e.options.debugAll) != null ? c : e.options.debugColumns;
      }
    }),
    getLeafColumns: S(() => [e._getOrderColumnsFn()], (c) => {
      var p;
      if ((p = d.columns) != null && p.length) {
        let f = d.columns.flatMap((m) => m.getLeafColumns());
        return c(f);
      }
      return [d];
    }, {
      key: process.env.NODE_ENV === "production" && "column.getLeafColumns",
      debug: () => {
        var c;
        return (c = e.options.debugAll) != null ? c : e.options.debugColumns;
      }
    })
  };
  for (const c of e._features)
    c.createColumn == null || c.createColumn(d, e);
  return d;
}
function Y(e, t, n) {
  var o;
  let i = {
    id: (o = n.id) != null ? o : t.id,
    column: t,
    index: n.index,
    isPlaceholder: !!n.isPlaceholder,
    placeholderId: n.placeholderId,
    depth: n.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const l = [], u = (g) => {
        g.subHeaders && g.subHeaders.length && g.subHeaders.map(u), l.push(g);
      };
      return u(i), l;
    },
    getContext: () => ({
      table: e,
      header: i,
      column: t
    })
  };
  return e._features.forEach((l) => {
    l.createHeader == null || l.createHeader(i, e);
  }), i;
}
const Se = {
  createTable: (e) => {
    e.getHeaderGroups = S(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, o, r) => {
      var i, l;
      const u = (i = o == null ? void 0 : o.map((d) => n.find((c) => c.id === d)).filter(Boolean)) != null ? i : [], g = (l = r == null ? void 0 : r.map((d) => n.find((c) => c.id === d)).filter(Boolean)) != null ? l : [], a = n.filter((d) => !(o != null && o.includes(d.id)) && !(r != null && r.includes(d.id)));
      return P(t, [...u, ...a, ...g], e);
    }, {
      key: process.env.NODE_ENV === "development" && "getHeaderGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getCenterHeaderGroups = S(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, o, r) => (n = n.filter((i) => !(o != null && o.includes(i.id)) && !(r != null && r.includes(i.id))), P(t, n, e, "center")), {
      key: process.env.NODE_ENV === "development" && "getCenterHeaderGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getLeftHeaderGroups = S(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left], (t, n, o) => {
      var r;
      const i = (r = o == null ? void 0 : o.map((l) => n.find((u) => u.id === l)).filter(Boolean)) != null ? r : [];
      return P(t, i, e, "left");
    }, {
      key: process.env.NODE_ENV === "development" && "getLeftHeaderGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getRightHeaderGroups = S(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.right], (t, n, o) => {
      var r;
      const i = (r = o == null ? void 0 : o.map((l) => n.find((u) => u.id === l)).filter(Boolean)) != null ? r : [];
      return P(t, i, e, "right");
    }, {
      key: process.env.NODE_ENV === "development" && "getRightHeaderGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getFooterGroups = S(() => [e.getHeaderGroups()], (t) => [...t].reverse(), {
      key: process.env.NODE_ENV === "development" && "getFooterGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getLeftFooterGroups = S(() => [e.getLeftHeaderGroups()], (t) => [...t].reverse(), {
      key: process.env.NODE_ENV === "development" && "getLeftFooterGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getCenterFooterGroups = S(() => [e.getCenterHeaderGroups()], (t) => [...t].reverse(), {
      key: process.env.NODE_ENV === "development" && "getCenterFooterGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getRightFooterGroups = S(() => [e.getRightHeaderGroups()], (t) => [...t].reverse(), {
      key: process.env.NODE_ENV === "development" && "getRightFooterGroups",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getFlatHeaders = S(() => [e.getHeaderGroups()], (t) => t.map((n) => n.headers).flat(), {
      key: process.env.NODE_ENV === "development" && "getFlatHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getLeftFlatHeaders = S(() => [e.getLeftHeaderGroups()], (t) => t.map((n) => n.headers).flat(), {
      key: process.env.NODE_ENV === "development" && "getLeftFlatHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getCenterFlatHeaders = S(() => [e.getCenterHeaderGroups()], (t) => t.map((n) => n.headers).flat(), {
      key: process.env.NODE_ENV === "development" && "getCenterFlatHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getRightFlatHeaders = S(() => [e.getRightHeaderGroups()], (t) => t.map((n) => n.headers).flat(), {
      key: process.env.NODE_ENV === "development" && "getRightFlatHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getCenterLeafHeaders = S(() => [e.getCenterFlatHeaders()], (t) => t.filter((n) => {
      var o;
      return !((o = n.subHeaders) != null && o.length);
    }), {
      key: process.env.NODE_ENV === "development" && "getCenterLeafHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getLeftLeafHeaders = S(() => [e.getLeftFlatHeaders()], (t) => t.filter((n) => {
      var o;
      return !((o = n.subHeaders) != null && o.length);
    }), {
      key: process.env.NODE_ENV === "development" && "getLeftLeafHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getRightLeafHeaders = S(() => [e.getRightFlatHeaders()], (t) => t.filter((n) => {
      var o;
      return !((o = n.subHeaders) != null && o.length);
    }), {
      key: process.env.NODE_ENV === "development" && "getRightLeafHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    }), e.getLeafHeaders = S(() => [e.getLeftHeaderGroups(), e.getCenterHeaderGroups(), e.getRightHeaderGroups()], (t, n, o) => {
      var r, i, l, u, g, a;
      return [...(r = (i = t[0]) == null ? void 0 : i.headers) != null ? r : [], ...(l = (u = n[0]) == null ? void 0 : u.headers) != null ? l : [], ...(g = (a = o[0]) == null ? void 0 : a.headers) != null ? g : []].map((s) => s.getLeafHeaders()).flat();
    }, {
      key: process.env.NODE_ENV === "development" && "getLeafHeaders",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugHeaders;
      }
    });
  }
};
function P(e, t, n, o) {
  var r, i;
  let l = 0;
  const u = function(c, p) {
    p === void 0 && (p = 1), l = Math.max(l, p), c.filter((f) => f.getIsVisible()).forEach((f) => {
      var m;
      (m = f.columns) != null && m.length && u(f.columns, p + 1);
    }, 0);
  };
  u(e);
  let g = [];
  const a = (c, p) => {
    const f = {
      depth: p,
      id: [o, `${p}`].filter(Boolean).join("_"),
      headers: []
    }, m = [];
    c.forEach((C) => {
      const v = [...m].reverse()[0], w = C.column.depth === f.depth;
      let R, h = !1;
      if (w && C.column.parent ? R = C.column.parent : (R = C.column, h = !0), v && (v == null ? void 0 : v.column) === R)
        v.subHeaders.push(C);
      else {
        const F = Y(n, R, {
          id: [o, p, R.id, C == null ? void 0 : C.id].filter(Boolean).join("_"),
          isPlaceholder: h,
          placeholderId: h ? `${m.filter((I) => I.column === R).length}` : void 0,
          depth: p,
          index: m.length
        });
        F.subHeaders.push(C), m.push(F);
      }
      f.headers.push(C), C.headerGroup = f;
    }), g.push(f), p > 0 && a(m, p - 1);
  }, s = t.map((c, p) => Y(n, c, {
    depth: l,
    index: p
  }));
  a(s, l - 1), g.reverse();
  const d = (c) => c.filter((f) => f.column.getIsVisible()).map((f) => {
    let m = 0, C = 0, v = [0];
    f.subHeaders && f.subHeaders.length ? (v = [], d(f.subHeaders).forEach((R) => {
      let {
        colSpan: h,
        rowSpan: F
      } = R;
      m += h, v.push(F);
    })) : m = 1;
    const w = Math.min(...v);
    return C = C + w, f.colSpan = m, f.rowSpan = C, {
      colSpan: m,
      rowSpan: C
    };
  });
  return d((r = (i = g[0]) == null ? void 0 : i.headers) != null ? r : []), g;
}
const x = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
}, H = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: !1,
  columnSizingStart: []
}), me = {
  getDefaultColumnDef: () => x,
  getInitialState: (e) => ({
    columnSizing: {},
    columnSizingInfo: H(),
    ...e
  }),
  getDefaultOptions: (e) => ({
    columnResizeMode: "onEnd",
    columnResizeDirection: "ltr",
    onColumnSizingChange: _("columnSizing", e),
    onColumnSizingInfoChange: _("columnSizingInfo", e)
  }),
  createColumn: (e, t) => {
    e.getSize = () => {
      var n, o, r;
      const i = t.getState().columnSizing[e.id];
      return Math.min(Math.max((n = e.columnDef.minSize) != null ? n : x.minSize, (o = i ?? e.columnDef.size) != null ? o : x.size), (r = e.columnDef.maxSize) != null ? r : x.maxSize);
    }, e.getStart = (n) => {
      const o = n ? n === "left" ? t.getLeftVisibleLeafColumns() : t.getRightVisibleLeafColumns() : t.getVisibleLeafColumns(), r = o.findIndex((i) => i.id === e.id);
      if (r > 0) {
        const i = o[r - 1];
        return i.getStart(n) + i.getSize();
      }
      return 0;
    }, e.resetSize = () => {
      t.setColumnSizing((n) => {
        let {
          [e.id]: o,
          ...r
        } = n;
        return r;
      });
    }, e.getCanResize = () => {
      var n, o;
      return ((n = e.columnDef.enableResizing) != null ? n : !0) && ((o = t.options.enableColumnResizing) != null ? o : !0);
    }, e.getIsResizing = () => t.getState().columnSizingInfo.isResizingColumn === e.id;
  },
  createHeader: (e, t) => {
    e.getSize = () => {
      let n = 0;
      const o = (r) => {
        if (r.subHeaders.length)
          r.subHeaders.forEach(o);
        else {
          var i;
          n += (i = r.column.getSize()) != null ? i : 0;
        }
      };
      return o(e), n;
    }, e.getStart = () => {
      if (e.index > 0) {
        const n = e.headerGroup.headers[e.index - 1];
        return n.getStart() + n.getSize();
      }
      return 0;
    }, e.getResizeHandler = (n) => {
      const o = t.getColumn(e.column.id), r = o == null ? void 0 : o.getCanResize();
      return (i) => {
        if (!o || !r || (i.persist == null || i.persist(), N(i) && i.touches && i.touches.length > 1))
          return;
        const l = e.getSize(), u = e ? e.getLeafHeaders().map((v) => [v.column.id, v.column.getSize()]) : [[o.id, o.getSize()]], g = N(i) ? Math.round(i.touches[0].clientX) : i.clientX, a = {}, s = (v, w) => {
          typeof w == "number" && (t.setColumnSizingInfo((R) => {
            var h, F;
            const I = t.options.columnResizeDirection === "rtl" ? -1 : 1, J = (w - ((h = R == null ? void 0 : R.startOffset) != null ? h : 0)) * I, Q = Math.max(J / ((F = R == null ? void 0 : R.startSize) != null ? F : 0), -0.999999);
            return R.columnSizingStart.forEach((ae) => {
              let [de, W] = ae;
              a[de] = Math.round(Math.max(W + W * Q, 0) * 100) / 100;
            }), {
              ...R,
              deltaOffset: J,
              deltaPercentage: Q
            };
          }), (t.options.columnResizeMode === "onChange" || v === "end") && t.setColumnSizing((R) => ({
            ...R,
            ...a
          })));
        }, d = (v) => s("move", v), c = (v) => {
          s("end", v), t.setColumnSizingInfo((w) => ({
            ...w,
            isResizingColumn: !1,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        }, p = n || typeof document < "u" ? document : null, f = {
          moveHandler: (v) => d(v.clientX),
          upHandler: (v) => {
            p == null || p.removeEventListener("mousemove", f.moveHandler), p == null || p.removeEventListener("mouseup", f.upHandler), c(v.clientX);
          }
        }, m = {
          moveHandler: (v) => (v.cancelable && (v.preventDefault(), v.stopPropagation()), d(v.touches[0].clientX), !1),
          upHandler: (v) => {
            var w;
            p == null || p.removeEventListener("touchmove", m.moveHandler), p == null || p.removeEventListener("touchend", m.upHandler), v.cancelable && (v.preventDefault(), v.stopPropagation()), c((w = v.touches[0]) == null ? void 0 : w.clientX);
          }
        }, C = ve() ? {
          passive: !1
        } : !1;
        N(i) ? (p == null || p.addEventListener("touchmove", m.moveHandler, C), p == null || p.addEventListener("touchend", m.upHandler, C)) : (p == null || p.addEventListener("mousemove", f.moveHandler, C), p == null || p.addEventListener("mouseup", f.upHandler, C)), t.setColumnSizingInfo((v) => ({
          ...v,
          startOffset: g,
          startSize: l,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart: u,
          isResizingColumn: o.id
        }));
      };
    };
  },
  createTable: (e) => {
    e.setColumnSizing = (t) => e.options.onColumnSizingChange == null ? void 0 : e.options.onColumnSizingChange(t), e.setColumnSizingInfo = (t) => e.options.onColumnSizingInfoChange == null ? void 0 : e.options.onColumnSizingInfoChange(t), e.resetColumnSizing = (t) => {
      var n;
      e.setColumnSizing(t ? {} : (n = e.initialState.columnSizing) != null ? n : {});
    }, e.resetHeaderSizeInfo = (t) => {
      var n;
      e.setColumnSizingInfo(t ? H() : (n = e.initialState.columnSizingInfo) != null ? n : H());
    }, e.getTotalSize = () => {
      var t, n;
      return (t = (n = e.getHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, r) => o + r.getSize(), 0)) != null ? t : 0;
    }, e.getLeftTotalSize = () => {
      var t, n;
      return (t = (n = e.getLeftHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, r) => o + r.getSize(), 0)) != null ? t : 0;
    }, e.getCenterTotalSize = () => {
      var t, n;
      return (t = (n = e.getCenterHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, r) => o + r.getSize(), 0)) != null ? t : 0;
    }, e.getRightTotalSize = () => {
      var t, n;
      return (t = (n = e.getRightHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, r) => o + r.getSize(), 0)) != null ? t : 0;
    };
  }
};
let y = null;
function ve() {
  if (typeof y == "boolean")
    return y;
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    }, n = () => {
    };
    window.addEventListener("test", n, t), window.removeEventListener("test", n);
  } catch {
    e = !1;
  }
  return y = e, y;
}
function N(e) {
  return e.type === "touchstart";
}
const Ce = {
  getInitialState: (e) => ({
    expanded: {},
    ...e
  }),
  getDefaultOptions: (e) => ({
    onExpandedChange: _("expanded", e),
    paginateExpandedRows: !0
  }),
  createTable: (e) => {
    let t = !1, n = !1;
    e._autoResetExpanded = () => {
      var o, r;
      if (!t) {
        e._queue(() => {
          t = !0;
        });
        return;
      }
      if ((o = (r = e.options.autoResetAll) != null ? r : e.options.autoResetExpanded) != null ? o : !e.options.manualExpanding) {
        if (n)
          return;
        n = !0, e._queue(() => {
          e.resetExpanded(), n = !1;
        });
      }
    }, e.setExpanded = (o) => e.options.onExpandedChange == null ? void 0 : e.options.onExpandedChange(o), e.toggleAllRowsExpanded = (o) => {
      o ?? !e.getIsAllRowsExpanded() ? e.setExpanded(!0) : e.setExpanded({});
    }, e.resetExpanded = (o) => {
      var r, i;
      e.setExpanded(o ? {} : (r = (i = e.initialState) == null ? void 0 : i.expanded) != null ? r : {});
    }, e.getCanSomeRowsExpand = () => e.getPrePaginationRowModel().flatRows.some((o) => o.getCanExpand()), e.getToggleAllRowsExpandedHandler = () => (o) => {
      o.persist == null || o.persist(), e.toggleAllRowsExpanded();
    }, e.getIsSomeRowsExpanded = () => {
      const o = e.getState().expanded;
      return o === !0 || Object.values(o).some(Boolean);
    }, e.getIsAllRowsExpanded = () => {
      const o = e.getState().expanded;
      return typeof o == "boolean" ? o === !0 : !(!Object.keys(o).length || e.getRowModel().flatRows.some((r) => !r.getIsExpanded()));
    }, e.getExpandedDepth = () => {
      let o = 0;
      return (e.getState().expanded === !0 ? Object.keys(e.getRowModel().rowsById) : Object.keys(e.getState().expanded)).forEach((i) => {
        const l = i.split(".");
        o = Math.max(o, l.length);
      }), o;
    }, e.getPreExpandedRowModel = () => e.getSortedRowModel(), e.getExpandedRowModel = () => (!e._getExpandedRowModel && e.options.getExpandedRowModel && (e._getExpandedRowModel = e.options.getExpandedRowModel(e)), e.options.manualExpanding || !e._getExpandedRowModel ? e.getPreExpandedRowModel() : e._getExpandedRowModel());
  },
  createRow: (e, t) => {
    e.toggleExpanded = (n) => {
      t.setExpanded((o) => {
        var r;
        const i = o === !0 ? !0 : !!(o != null && o[e.id]);
        let l = {};
        if (o === !0 ? Object.keys(t.getRowModel().rowsById).forEach((u) => {
          l[u] = !0;
        }) : l = o, n = (r = n) != null ? r : !i, !i && n)
          return {
            ...l,
            [e.id]: !0
          };
        if (i && !n) {
          const {
            [e.id]: u,
            ...g
          } = l;
          return g;
        }
        return o;
      });
    }, e.getIsExpanded = () => {
      var n;
      const o = t.getState().expanded;
      return !!((n = t.options.getIsRowExpanded == null ? void 0 : t.options.getIsRowExpanded(e)) != null ? n : o === !0 || o != null && o[e.id]);
    }, e.getCanExpand = () => {
      var n, o, r;
      return (n = t.options.getRowCanExpand == null ? void 0 : t.options.getRowCanExpand(e)) != null ? n : ((o = t.options.enableExpanding) != null ? o : !0) && !!((r = e.subRows) != null && r.length);
    }, e.getIsAllParentsExpanded = () => {
      let n = !0, o = e;
      for (; n && o.parentId; )
        o = t.getRow(o.parentId, !0), n = o.getIsExpanded();
      return n;
    }, e.getToggleExpandedHandler = () => {
      const n = e.getCanExpand();
      return () => {
        n && e.toggleExpanded();
      };
    };
  }
}, ne = (e, t, n) => {
  var o;
  const r = n.toLowerCase();
  return !!(!((o = e.getValue(t)) == null || (o = o.toString()) == null || (o = o.toLowerCase()) == null) && o.includes(r));
};
ne.autoRemove = (e) => $(e);
const te = (e, t, n) => {
  var o;
  return !!(!((o = e.getValue(t)) == null || (o = o.toString()) == null) && o.includes(n));
};
te.autoRemove = (e) => $(e);
const oe = (e, t, n) => {
  var o;
  return ((o = e.getValue(t)) == null || (o = o.toString()) == null ? void 0 : o.toLowerCase()) === (n == null ? void 0 : n.toLowerCase());
};
oe.autoRemove = (e) => $(e);
const re = (e, t, n) => {
  var o;
  return (o = e.getValue(t)) == null ? void 0 : o.includes(n);
};
re.autoRemove = (e) => $(e) || !(e != null && e.length);
const ie = (e, t, n) => !n.some((o) => {
  var r;
  return !((r = e.getValue(t)) != null && r.includes(o));
});
ie.autoRemove = (e) => $(e) || !(e != null && e.length);
const le = (e, t, n) => n.some((o) => {
  var r;
  return (r = e.getValue(t)) == null ? void 0 : r.includes(o);
});
le.autoRemove = (e) => $(e) || !(e != null && e.length);
const ue = (e, t, n) => e.getValue(t) === n;
ue.autoRemove = (e) => $(e);
const se = (e, t, n) => e.getValue(t) == n;
se.autoRemove = (e) => $(e);
const j = (e, t, n) => {
  let [o, r] = n;
  const i = e.getValue(t);
  return i >= o && i <= r;
};
j.resolveFilterValue = (e) => {
  let [t, n] = e, o = typeof t != "number" ? parseFloat(t) : t, r = typeof n != "number" ? parseFloat(n) : n, i = t === null || Number.isNaN(o) ? -1 / 0 : o, l = n === null || Number.isNaN(r) ? 1 / 0 : r;
  if (i > l) {
    const u = i;
    i = l, l = u;
  }
  return [i, l];
};
j.autoRemove = (e) => $(e) || $(e[0]) && $(e[1]);
const V = {
  includesString: ne,
  includesStringSensitive: te,
  equalsString: oe,
  arrIncludes: re,
  arrIncludesAll: ie,
  arrIncludesSome: le,
  equals: ue,
  weakEquals: se,
  inNumberRange: j
};
function $(e) {
  return e == null || e === "";
}
const Re = {
  getDefaultColumnDef: () => ({
    filterFn: "auto"
  }),
  getInitialState: (e) => ({
    columnFilters: [],
    globalFilter: void 0,
    // filtersProgress: 1,
    // facetProgress: {},
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnFiltersChange: _("columnFilters", e),
    onGlobalFilterChange: _("globalFilter", e),
    filterFromLeafRows: !1,
    maxLeafRowFilterDepth: 100,
    globalFilterFn: "auto",
    getColumnCanGlobalFilter: (t) => {
      var n;
      const o = (n = e.getCoreRowModel().flatRows[0]) == null || (n = n._getAllCellsByColumnId()[t.id]) == null ? void 0 : n.getValue();
      return typeof o == "string" || typeof o == "number";
    }
  }),
  createColumn: (e, t) => {
    e.getAutoFilterFn = () => {
      const n = t.getCoreRowModel().flatRows[0], o = n == null ? void 0 : n.getValue(e.id);
      return typeof o == "string" ? V.includesString : typeof o == "number" ? V.inNumberRange : typeof o == "boolean" || o !== null && typeof o == "object" ? V.equals : Array.isArray(o) ? V.arrIncludes : V.weakEquals;
    }, e.getFilterFn = () => {
      var n, o;
      return D(e.columnDef.filterFn) ? e.columnDef.filterFn : e.columnDef.filterFn === "auto" ? e.getAutoFilterFn() : (
        // @ts-ignore
        (n = (o = t.options.filterFns) == null ? void 0 : o[e.columnDef.filterFn]) != null ? n : V[e.columnDef.filterFn]
      );
    }, e.getCanFilter = () => {
      var n, o, r;
      return ((n = e.columnDef.enableColumnFilter) != null ? n : !0) && ((o = t.options.enableColumnFilters) != null ? o : !0) && ((r = t.options.enableFilters) != null ? r : !0) && !!e.accessorFn;
    }, e.getCanGlobalFilter = () => {
      var n, o, r, i;
      return ((n = e.columnDef.enableGlobalFilter) != null ? n : !0) && ((o = t.options.enableGlobalFilter) != null ? o : !0) && ((r = t.options.enableFilters) != null ? r : !0) && ((i = t.options.getColumnCanGlobalFilter == null ? void 0 : t.options.getColumnCanGlobalFilter(e)) != null ? i : !0) && !!e.accessorFn;
    }, e.getIsFiltered = () => e.getFilterIndex() > -1, e.getFilterValue = () => {
      var n;
      return (n = t.getState().columnFilters) == null || (n = n.find((o) => o.id === e.id)) == null ? void 0 : n.value;
    }, e.getFilterIndex = () => {
      var n, o;
      return (n = (o = t.getState().columnFilters) == null ? void 0 : o.findIndex((r) => r.id === e.id)) != null ? n : -1;
    }, e.setFilterValue = (n) => {
      t.setColumnFilters((o) => {
        const r = e.getFilterFn(), i = o == null ? void 0 : o.find((s) => s.id === e.id), l = E(n, i ? i.value : void 0);
        if (Z(r, l, e)) {
          var u;
          return (u = o == null ? void 0 : o.filter((s) => s.id !== e.id)) != null ? u : [];
        }
        const g = {
          id: e.id,
          value: l
        };
        if (i) {
          var a;
          return (a = o == null ? void 0 : o.map((s) => s.id === e.id ? g : s)) != null ? a : [];
        }
        return o != null && o.length ? [...o, g] : [g];
      });
    }, e._getFacetedRowModel = t.options.getFacetedRowModel && t.options.getFacetedRowModel(t, e.id), e.getFacetedRowModel = () => e._getFacetedRowModel ? e._getFacetedRowModel() : t.getPreFilteredRowModel(), e._getFacetedUniqueValues = t.options.getFacetedUniqueValues && t.options.getFacetedUniqueValues(t, e.id), e.getFacetedUniqueValues = () => e._getFacetedUniqueValues ? e._getFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getFacetedMinMaxValues = t.options.getFacetedMinMaxValues && t.options.getFacetedMinMaxValues(t, e.id), e.getFacetedMinMaxValues = () => {
      if (e._getFacetedMinMaxValues)
        return e._getFacetedMinMaxValues();
    };
  },
  createRow: (e, t) => {
    e.columnFilters = {}, e.columnFiltersMeta = {};
  },
  createTable: (e) => {
    e.getGlobalAutoFilterFn = () => V.includesString, e.getGlobalFilterFn = () => {
      var t, n;
      const {
        globalFilterFn: o
      } = e.options;
      return D(o) ? o : o === "auto" ? e.getGlobalAutoFilterFn() : (
        // @ts-ignore
        (t = (n = e.options.filterFns) == null ? void 0 : n[o]) != null ? t : V[o]
      );
    }, e.setColumnFilters = (t) => {
      const n = e.getAllLeafColumns(), o = (r) => {
        var i;
        return (i = E(t, r)) == null ? void 0 : i.filter((l) => {
          const u = n.find((g) => g.id === l.id);
          if (u) {
            const g = u.getFilterFn();
            if (Z(g, l.value, u))
              return !1;
          }
          return !0;
        });
      };
      e.options.onColumnFiltersChange == null || e.options.onColumnFiltersChange(o);
    }, e.setGlobalFilter = (t) => {
      e.options.onGlobalFilterChange == null || e.options.onGlobalFilterChange(t);
    }, e.resetGlobalFilter = (t) => {
      e.setGlobalFilter(t ? void 0 : e.initialState.globalFilter);
    }, e.resetColumnFilters = (t) => {
      var n, o;
      e.setColumnFilters(t ? [] : (n = (o = e.initialState) == null ? void 0 : o.columnFilters) != null ? n : []);
    }, e.getPreFilteredRowModel = () => e.getCoreRowModel(), e.getFilteredRowModel = () => (!e._getFilteredRowModel && e.options.getFilteredRowModel && (e._getFilteredRowModel = e.options.getFilteredRowModel(e)), e.options.manualFiltering || !e._getFilteredRowModel ? e.getPreFilteredRowModel() : e._getFilteredRowModel()), e._getGlobalFacetedRowModel = e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, "__global__"), e.getGlobalFacetedRowModel = () => e.options.manualFiltering || !e._getGlobalFacetedRowModel ? e.getPreFilteredRowModel() : e._getGlobalFacetedRowModel(), e._getGlobalFacetedUniqueValues = e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, "__global__"), e.getGlobalFacetedUniqueValues = () => e._getGlobalFacetedUniqueValues ? e._getGlobalFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getGlobalFacetedMinMaxValues = e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, "__global__"), e.getGlobalFacetedMinMaxValues = () => {
      if (e._getGlobalFacetedMinMaxValues)
        return e._getGlobalFacetedMinMaxValues();
    };
  }
};
function Z(e, t, n) {
  return (e && e.autoRemove ? e.autoRemove(t, n) : !1) || typeof t > "u" || typeof t == "string" && !t;
}
const we = (e, t, n) => n.reduce((o, r) => {
  const i = r.getValue(e);
  return o + (typeof i == "number" ? i : 0);
}, 0), _e = (e, t, n) => {
  let o;
  return n.forEach((r) => {
    const i = r.getValue(e);
    i != null && (o > i || o === void 0 && i >= i) && (o = i);
  }), o;
}, he = (e, t, n) => {
  let o;
  return n.forEach((r) => {
    const i = r.getValue(e);
    i != null && (o < i || o === void 0 && i >= i) && (o = i);
  }), o;
}, $e = (e, t, n) => {
  let o, r;
  return n.forEach((i) => {
    const l = i.getValue(e);
    l != null && (o === void 0 ? l >= l && (o = r = l) : (o > l && (o = l), r < l && (r = l)));
  }), [o, r];
}, Fe = (e, t) => {
  let n = 0, o = 0;
  if (t.forEach((r) => {
    let i = r.getValue(e);
    i != null && (i = +i) >= i && (++n, o += i);
  }), n)
    return o / n;
}, Ve = (e, t) => {
  if (!t.length)
    return;
  const n = t.map((i) => i.getValue(e));
  if (!pe(n))
    return;
  if (n.length === 1)
    return n[0];
  const o = Math.floor(n.length / 2), r = n.sort((i, l) => i - l);
  return n.length % 2 !== 0 ? r[o] : (r[o - 1] + r[o]) / 2;
}, Ee = (e, t) => Array.from(new Set(t.map((n) => n.getValue(e))).values()), Ae = (e, t) => new Set(t.map((n) => n.getValue(e))).size, Me = (e, t) => t.length, O = {
  sum: we,
  min: _e,
  max: he,
  extent: $e,
  mean: Fe,
  median: Ve,
  unique: Ee,
  uniqueCount: Ae,
  count: Me
}, Pe = {
  getDefaultColumnDef: () => ({
    aggregatedCell: (e) => {
      var t, n;
      return (t = (n = e.getValue()) == null || n.toString == null ? void 0 : n.toString()) != null ? t : null;
    },
    aggregationFn: "auto"
  }),
  getInitialState: (e) => ({
    grouping: [],
    ...e
  }),
  getDefaultOptions: (e) => ({
    onGroupingChange: _("grouping", e),
    groupedColumnMode: "reorder"
  }),
  createColumn: (e, t) => {
    e.toggleGrouping = () => {
      t.setGrouping((n) => n != null && n.includes(e.id) ? n.filter((o) => o !== e.id) : [...n ?? [], e.id]);
    }, e.getCanGroup = () => {
      var n, o, r, i;
      return (n = (o = (r = (i = e.columnDef.enableGrouping) != null ? i : !0) != null ? r : t.options.enableGrouping) != null ? o : !0) != null ? n : !!e.accessorFn;
    }, e.getIsGrouped = () => {
      var n;
      return (n = t.getState().grouping) == null ? void 0 : n.includes(e.id);
    }, e.getGroupedIndex = () => {
      var n;
      return (n = t.getState().grouping) == null ? void 0 : n.indexOf(e.id);
    }, e.getToggleGroupingHandler = () => {
      const n = e.getCanGroup();
      return () => {
        n && e.toggleGrouping();
      };
    }, e.getAutoAggregationFn = () => {
      const n = t.getCoreRowModel().flatRows[0], o = n == null ? void 0 : n.getValue(e.id);
      if (typeof o == "number")
        return O.sum;
      if (Object.prototype.toString.call(o) === "[object Date]")
        return O.extent;
    }, e.getAggregationFn = () => {
      var n, o;
      if (!e)
        throw new Error();
      return D(e.columnDef.aggregationFn) ? e.columnDef.aggregationFn : e.columnDef.aggregationFn === "auto" ? e.getAutoAggregationFn() : (n = (o = t.options.aggregationFns) == null ? void 0 : o[e.columnDef.aggregationFn]) != null ? n : O[e.columnDef.aggregationFn];
    };
  },
  createTable: (e) => {
    e.setGrouping = (t) => e.options.onGroupingChange == null ? void 0 : e.options.onGroupingChange(t), e.resetGrouping = (t) => {
      var n, o;
      e.setGrouping(t ? [] : (n = (o = e.initialState) == null ? void 0 : o.grouping) != null ? n : []);
    }, e.getPreGroupedRowModel = () => e.getFilteredRowModel(), e.getGroupedRowModel = () => (!e._getGroupedRowModel && e.options.getGroupedRowModel && (e._getGroupedRowModel = e.options.getGroupedRowModel(e)), e.options.manualGrouping || !e._getGroupedRowModel ? e.getPreGroupedRowModel() : e._getGroupedRowModel());
  },
  createRow: (e, t) => {
    e.getIsGrouped = () => !!e.groupingColumnId, e.getGroupingValue = (n) => {
      if (e._groupingValuesCache.hasOwnProperty(n))
        return e._groupingValuesCache[n];
      const o = t.getColumn(n);
      return o != null && o.columnDef.getGroupingValue ? (e._groupingValuesCache[n] = o.columnDef.getGroupingValue(e.original), e._groupingValuesCache[n]) : e.getValue(n);
    }, e._groupingValuesCache = {};
  },
  createCell: (e, t, n, o) => {
    e.getIsGrouped = () => t.getIsGrouped() && t.id === n.groupingColumnId, e.getIsPlaceholder = () => !e.getIsGrouped() && t.getIsGrouped(), e.getIsAggregated = () => {
      var r;
      return !e.getIsGrouped() && !e.getIsPlaceholder() && !!((r = n.subRows) != null && r.length);
    };
  }
};
function xe(e, t, n) {
  if (!(t != null && t.length) || !n)
    return e;
  const o = e.filter((i) => !t.includes(i.id));
  return n === "remove" ? o : [...t.map((i) => e.find((l) => l.id === i)).filter(Boolean), ...o];
}
const ye = {
  getInitialState: (e) => ({
    columnOrder: [],
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnOrderChange: _("columnOrder", e)
  }),
  createTable: (e) => {
    e.setColumnOrder = (t) => e.options.onColumnOrderChange == null ? void 0 : e.options.onColumnOrderChange(t), e.resetColumnOrder = (t) => {
      var n;
      e.setColumnOrder(t ? [] : (n = e.initialState.columnOrder) != null ? n : []);
    }, e._getOrderColumnsFn = S(() => [e.getState().columnOrder, e.getState().grouping, e.options.groupedColumnMode], (t, n, o) => (r) => {
      let i = [];
      if (!(t != null && t.length))
        i = r;
      else {
        const l = [...t], u = [...r];
        for (; u.length && l.length; ) {
          const g = l.shift(), a = u.findIndex((s) => s.id === g);
          a > -1 && i.push(u.splice(a, 1)[0]);
        }
        i = [...i, ...u];
      }
      return xe(i, n, o);
    }, {
      key: process.env.NODE_ENV === "development" && "getOrderColumnsFn"
      // debug: () => table.options.debugAll ?? table.options.debugTable,
    });
  }
}, B = 0, b = 10, G = () => ({
  pageIndex: B,
  pageSize: b
}), De = {
  getInitialState: (e) => ({
    ...e,
    pagination: {
      ...G(),
      ...e == null ? void 0 : e.pagination
    }
  }),
  getDefaultOptions: (e) => ({
    onPaginationChange: _("pagination", e)
  }),
  createTable: (e) => {
    let t = !1, n = !1;
    e._autoResetPageIndex = () => {
      var o, r;
      if (!t) {
        e._queue(() => {
          t = !0;
        });
        return;
      }
      if ((o = (r = e.options.autoResetAll) != null ? r : e.options.autoResetPageIndex) != null ? o : !e.options.manualPagination) {
        if (n)
          return;
        n = !0, e._queue(() => {
          e.resetPageIndex(), n = !1;
        });
      }
    }, e.setPagination = (o) => {
      const r = (i) => E(o, i);
      return e.options.onPaginationChange == null ? void 0 : e.options.onPaginationChange(r);
    }, e.resetPagination = (o) => {
      var r;
      e.setPagination(o ? G() : (r = e.initialState.pagination) != null ? r : G());
    }, e.setPageIndex = (o) => {
      e.setPagination((r) => {
        let i = E(o, r.pageIndex);
        const l = typeof e.options.pageCount > "u" || e.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : e.options.pageCount - 1;
        return i = Math.max(0, Math.min(i, l)), {
          ...r,
          pageIndex: i
        };
      });
    }, e.resetPageIndex = (o) => {
      var r, i;
      e.setPageIndex(o ? B : (r = (i = e.initialState) == null || (i = i.pagination) == null ? void 0 : i.pageIndex) != null ? r : B);
    }, e.resetPageSize = (o) => {
      var r, i;
      e.setPageSize(o ? b : (r = (i = e.initialState) == null || (i = i.pagination) == null ? void 0 : i.pageSize) != null ? r : b);
    }, e.setPageSize = (o) => {
      e.setPagination((r) => {
        const i = Math.max(1, E(o, r.pageSize)), l = r.pageSize * r.pageIndex, u = Math.floor(l / i);
        return {
          ...r,
          pageIndex: u,
          pageSize: i
        };
      });
    }, e.setPageCount = (o) => e.setPagination((r) => {
      var i;
      let l = E(o, (i = e.options.pageCount) != null ? i : -1);
      return typeof l == "number" && (l = Math.max(-1, l)), {
        ...r,
        pageCount: l
      };
    }), e.getPageOptions = S(() => [e.getPageCount()], (o) => {
      let r = [];
      return o && o > 0 && (r = [...new Array(o)].fill(null).map((i, l) => l)), r;
    }, {
      key: process.env.NODE_ENV === "development" && "getPageOptions",
      debug: () => {
        var o;
        return (o = e.options.debugAll) != null ? o : e.options.debugTable;
      }
    }), e.getCanPreviousPage = () => e.getState().pagination.pageIndex > 0, e.getCanNextPage = () => {
      const {
        pageIndex: o
      } = e.getState().pagination, r = e.getPageCount();
      return r === -1 ? !0 : r === 0 ? !1 : o < r - 1;
    }, e.previousPage = () => e.setPageIndex((o) => o - 1), e.nextPage = () => e.setPageIndex((o) => o + 1), e.getPrePaginationRowModel = () => e.getExpandedRowModel(), e.getPaginationRowModel = () => (!e._getPaginationRowModel && e.options.getPaginationRowModel && (e._getPaginationRowModel = e.options.getPaginationRowModel(e)), e.options.manualPagination || !e._getPaginationRowModel ? e.getPrePaginationRowModel() : e._getPaginationRowModel()), e.getPageCount = () => {
      var o;
      return (o = e.options.pageCount) != null ? o : Math.ceil(e.getPrePaginationRowModel().rows.length / e.getState().pagination.pageSize);
    };
  }
}, L = () => ({
  left: [],
  right: []
}), z = () => ({
  top: [],
  bottom: []
}), Ie = {
  getInitialState: (e) => ({
    columnPinning: L(),
    rowPinning: z(),
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnPinningChange: _("columnPinning", e),
    onRowPinningChange: _("rowPinning", e)
  }),
  createColumn: (e, t) => {
    e.pin = (n) => {
      const o = e.getLeafColumns().map((r) => r.id).filter(Boolean);
      t.setColumnPinning((r) => {
        var i, l;
        if (n === "right") {
          var u, g;
          return {
            left: ((u = r == null ? void 0 : r.left) != null ? u : []).filter((d) => !(o != null && o.includes(d))),
            right: [...((g = r == null ? void 0 : r.right) != null ? g : []).filter((d) => !(o != null && o.includes(d))), ...o]
          };
        }
        if (n === "left") {
          var a, s;
          return {
            left: [...((a = r == null ? void 0 : r.left) != null ? a : []).filter((d) => !(o != null && o.includes(d))), ...o],
            right: ((s = r == null ? void 0 : r.right) != null ? s : []).filter((d) => !(o != null && o.includes(d)))
          };
        }
        return {
          left: ((i = r == null ? void 0 : r.left) != null ? i : []).filter((d) => !(o != null && o.includes(d))),
          right: ((l = r == null ? void 0 : r.right) != null ? l : []).filter((d) => !(o != null && o.includes(d)))
        };
      });
    }, e.getCanPin = () => e.getLeafColumns().some((o) => {
      var r, i, l;
      return ((r = o.columnDef.enablePinning) != null ? r : !0) && ((i = (l = t.options.enableColumnPinning) != null ? l : t.options.enablePinning) != null ? i : !0);
    }), e.getIsPinned = () => {
      const n = e.getLeafColumns().map((u) => u.id), {
        left: o,
        right: r
      } = t.getState().columnPinning, i = n.some((u) => o == null ? void 0 : o.includes(u)), l = n.some((u) => r == null ? void 0 : r.includes(u));
      return i ? "left" : l ? "right" : !1;
    }, e.getPinnedIndex = () => {
      var n, o;
      const r = e.getIsPinned();
      return r ? (n = (o = t.getState().columnPinning) == null || (o = o[r]) == null ? void 0 : o.indexOf(e.id)) != null ? n : -1 : 0;
    };
  },
  createRow: (e, t) => {
    e.pin = (n, o, r) => {
      const i = o ? e.getLeafRows().map((g) => {
        let {
          id: a
        } = g;
        return a;
      }) : [], l = r ? e.getParentRows().map((g) => {
        let {
          id: a
        } = g;
        return a;
      }) : [], u = /* @__PURE__ */ new Set([...l, e.id, ...i]);
      t.setRowPinning((g) => {
        var a, s;
        if (n === "bottom") {
          var d, c;
          return {
            top: ((d = g == null ? void 0 : g.top) != null ? d : []).filter((m) => !(u != null && u.has(m))),
            bottom: [...((c = g == null ? void 0 : g.bottom) != null ? c : []).filter((m) => !(u != null && u.has(m))), ...Array.from(u)]
          };
        }
        if (n === "top") {
          var p, f;
          return {
            top: [...((p = g == null ? void 0 : g.top) != null ? p : []).filter((m) => !(u != null && u.has(m))), ...Array.from(u)],
            bottom: ((f = g == null ? void 0 : g.bottom) != null ? f : []).filter((m) => !(u != null && u.has(m)))
          };
        }
        return {
          top: ((a = g == null ? void 0 : g.top) != null ? a : []).filter((m) => !(u != null && u.has(m))),
          bottom: ((s = g == null ? void 0 : g.bottom) != null ? s : []).filter((m) => !(u != null && u.has(m)))
        };
      });
    }, e.getCanPin = () => {
      var n;
      const {
        enableRowPinning: o,
        enablePinning: r
      } = t.options;
      return typeof o == "function" ? o(e) : (n = o ?? r) != null ? n : !0;
    }, e.getIsPinned = () => {
      const n = [e.id], {
        top: o,
        bottom: r
      } = t.getState().rowPinning, i = n.some((u) => o == null ? void 0 : o.includes(u)), l = n.some((u) => r == null ? void 0 : r.includes(u));
      return i ? "top" : l ? "bottom" : !1;
    }, e.getPinnedIndex = () => {
      var n, o;
      const r = e.getIsPinned();
      if (!r)
        return -1;
      const i = (n = t._getPinnedRows(r)) == null ? void 0 : n.map((l) => {
        let {
          id: u
        } = l;
        return u;
      });
      return (o = i == null ? void 0 : i.indexOf(e.id)) != null ? o : -1;
    }, e.getCenterVisibleCells = S(() => [e._getAllVisibleCells(), t.getState().columnPinning.left, t.getState().columnPinning.right], (n, o, r) => {
      const i = [...o ?? [], ...r ?? []];
      return n.filter((l) => !i.includes(l.column.id));
    }, {
      key: process.env.NODE_ENV === "development" && "row.getCenterVisibleCells",
      debug: () => {
        var n;
        return (n = t.options.debugAll) != null ? n : t.options.debugRows;
      }
    }), e.getLeftVisibleCells = S(() => [e._getAllVisibleCells(), t.getState().columnPinning.left, ,], (n, o) => (o ?? []).map((i) => n.find((l) => l.column.id === i)).filter(Boolean).map((i) => ({
      ...i,
      position: "left"
    })), {
      key: process.env.NODE_ENV === "development" && "row.getLeftVisibleCells",
      debug: () => {
        var n;
        return (n = t.options.debugAll) != null ? n : t.options.debugRows;
      }
    }), e.getRightVisibleCells = S(() => [e._getAllVisibleCells(), t.getState().columnPinning.right], (n, o) => (o ?? []).map((i) => n.find((l) => l.column.id === i)).filter(Boolean).map((i) => ({
      ...i,
      position: "right"
    })), {
      key: process.env.NODE_ENV === "development" && "row.getRightVisibleCells",
      debug: () => {
        var n;
        return (n = t.options.debugAll) != null ? n : t.options.debugRows;
      }
    });
  },
  createTable: (e) => {
    e.setColumnPinning = (t) => e.options.onColumnPinningChange == null ? void 0 : e.options.onColumnPinningChange(t), e.resetColumnPinning = (t) => {
      var n, o;
      return e.setColumnPinning(t ? L() : (n = (o = e.initialState) == null ? void 0 : o.columnPinning) != null ? n : L());
    }, e.getIsSomeColumnsPinned = (t) => {
      var n;
      const o = e.getState().columnPinning;
      if (!t) {
        var r, i;
        return !!((r = o.left) != null && r.length || (i = o.right) != null && i.length);
      }
      return !!((n = o[t]) != null && n.length);
    }, e.getLeftLeafColumns = S(() => [e.getAllLeafColumns(), e.getState().columnPinning.left], (t, n) => (n ?? []).map((o) => t.find((r) => r.id === o)).filter(Boolean), {
      key: process.env.NODE_ENV === "development" && "getLeftLeafColumns",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugColumns;
      }
    }), e.getRightLeafColumns = S(() => [e.getAllLeafColumns(), e.getState().columnPinning.right], (t, n) => (n ?? []).map((o) => t.find((r) => r.id === o)).filter(Boolean), {
      key: process.env.NODE_ENV === "development" && "getRightLeafColumns",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugColumns;
      }
    }), e.getCenterLeafColumns = S(() => [e.getAllLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, o) => {
      const r = [...n ?? [], ...o ?? []];
      return t.filter((i) => !r.includes(i.id));
    }, {
      key: process.env.NODE_ENV === "development" && "getCenterLeafColumns",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugColumns;
      }
    }), e.setRowPinning = (t) => e.options.onRowPinningChange == null ? void 0 : e.options.onRowPinningChange(t), e.resetRowPinning = (t) => {
      var n, o;
      return e.setRowPinning(t ? z() : (n = (o = e.initialState) == null ? void 0 : o.rowPinning) != null ? n : z());
    }, e.getIsSomeRowsPinned = (t) => {
      var n;
      const o = e.getState().rowPinning;
      if (!t) {
        var r, i;
        return !!((r = o.top) != null && r.length || (i = o.bottom) != null && i.length);
      }
      return !!((n = o[t]) != null && n.length);
    }, e._getPinnedRows = (t) => S(() => [e.getRowModel().rows, e.getState().rowPinning[t]], (n, o) => {
      var r;
      return ((r = e.options.keepPinnedRows) == null || r ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (o ?? []).map((l) => {
          const u = e.getRow(l, !0);
          return u.getIsAllParentsExpanded() ? u : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (o ?? []).map((l) => n.find((u) => u.id === l))
      )).filter(Boolean).map((l) => ({
        ...l,
        position: t
      }));
    }, {
      key: process.env.NODE_ENV === "development" && `row.get${t === "top" ? "Top" : "Bottom"}Rows`,
      debug: () => {
        var n;
        return (n = e.options.debugAll) != null ? n : e.options.debugRows;
      }
    })(), e.getTopRows = () => e._getPinnedRows("top"), e.getBottomRows = () => e._getPinnedRows("bottom"), e.getCenterRows = S(() => [e.getRowModel().rows, e.getState().rowPinning.top, e.getState().rowPinning.bottom], (t, n, o) => {
      const r = /* @__PURE__ */ new Set([...n ?? [], ...o ?? []]);
      return t.filter((i) => !r.has(i.id));
    }, {
      key: process.env.NODE_ENV === "development" && "row.getCenterRows",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugRows;
      }
    });
  }
}, He = {
  getInitialState: (e) => ({
    rowSelection: {},
    ...e
  }),
  getDefaultOptions: (e) => ({
    onRowSelectionChange: _("rowSelection", e),
    enableRowSelection: !0,
    enableMultiRowSelection: !0,
    enableSubRowSelection: !0
    // enableGroupingRowSelection: false,
    // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
    // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
  }),
  createTable: (e) => {
    e.setRowSelection = (t) => e.options.onRowSelectionChange == null ? void 0 : e.options.onRowSelectionChange(t), e.resetRowSelection = (t) => {
      var n;
      return e.setRowSelection(t ? {} : (n = e.initialState.rowSelection) != null ? n : {});
    }, e.toggleAllRowsSelected = (t) => {
      e.setRowSelection((n) => {
        t = typeof t < "u" ? t : !e.getIsAllRowsSelected();
        const o = {
          ...n
        }, r = e.getPreGroupedRowModel().flatRows;
        return t ? r.forEach((i) => {
          i.getCanSelect() && (o[i.id] = !0);
        }) : r.forEach((i) => {
          delete o[i.id];
        }), o;
      });
    }, e.toggleAllPageRowsSelected = (t) => e.setRowSelection((n) => {
      const o = typeof t < "u" ? t : !e.getIsAllPageRowsSelected(), r = {
        ...n
      };
      return e.getRowModel().rows.forEach((i) => {
        q(r, i.id, o, !0, e);
      }), r;
    }), e.getPreSelectedRowModel = () => e.getCoreRowModel(), e.getSelectedRowModel = S(() => [e.getState().rowSelection, e.getCoreRowModel()], (t, n) => Object.keys(t).length ? k(e, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, {
      key: process.env.NODE_ENV === "development" && "getSelectedRowModel",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugTable;
      }
    }), e.getFilteredSelectedRowModel = S(() => [e.getState().rowSelection, e.getFilteredRowModel()], (t, n) => Object.keys(t).length ? k(e, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, {
      key: process.env.NODE_ENV === "production" && "getFilteredSelectedRowModel",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugTable;
      }
    }), e.getGroupedSelectedRowModel = S(() => [e.getState().rowSelection, e.getSortedRowModel()], (t, n) => Object.keys(t).length ? k(e, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, {
      key: process.env.NODE_ENV === "production" && "getGroupedSelectedRowModel",
      debug: () => {
        var t;
        return (t = e.options.debugAll) != null ? t : e.options.debugTable;
      }
    }), e.getIsAllRowsSelected = () => {
      const t = e.getFilteredRowModel().flatRows, {
        rowSelection: n
      } = e.getState();
      let o = !!(t.length && Object.keys(n).length);
      return o && t.some((r) => r.getCanSelect() && !n[r.id]) && (o = !1), o;
    }, e.getIsAllPageRowsSelected = () => {
      const t = e.getPaginationRowModel().flatRows.filter((r) => r.getCanSelect()), {
        rowSelection: n
      } = e.getState();
      let o = !!t.length;
      return o && t.some((r) => !n[r.id]) && (o = !1), o;
    }, e.getIsSomeRowsSelected = () => {
      var t;
      const n = Object.keys((t = e.getState().rowSelection) != null ? t : {}).length;
      return n > 0 && n < e.getFilteredRowModel().flatRows.length;
    }, e.getIsSomePageRowsSelected = () => {
      const t = e.getPaginationRowModel().flatRows;
      return e.getIsAllPageRowsSelected() ? !1 : t.filter((n) => n.getCanSelect()).some((n) => n.getIsSelected() || n.getIsSomeSelected());
    }, e.getToggleAllRowsSelectedHandler = () => (t) => {
      e.toggleAllRowsSelected(t.target.checked);
    }, e.getToggleAllPageRowsSelectedHandler = () => (t) => {
      e.toggleAllPageRowsSelected(t.target.checked);
    };
  },
  createRow: (e, t) => {
    e.toggleSelected = (n, o) => {
      const r = e.getIsSelected();
      t.setRowSelection((i) => {
        var l;
        if (n = typeof n < "u" ? n : !r, e.getCanSelect() && r === n)
          return i;
        const u = {
          ...i
        };
        return q(u, e.id, n, (l = o == null ? void 0 : o.selectChildren) != null ? l : !0, t), u;
      });
    }, e.getIsSelected = () => {
      const {
        rowSelection: n
      } = t.getState();
      return X(e, n);
    }, e.getIsSomeSelected = () => {
      const {
        rowSelection: n
      } = t.getState();
      return T(e, n) === "some";
    }, e.getIsAllSubRowsSelected = () => {
      const {
        rowSelection: n
      } = t.getState();
      return T(e, n) === "all";
    }, e.getCanSelect = () => {
      var n;
      return typeof t.options.enableRowSelection == "function" ? t.options.enableRowSelection(e) : (n = t.options.enableRowSelection) != null ? n : !0;
    }, e.getCanSelectSubRows = () => {
      var n;
      return typeof t.options.enableSubRowSelection == "function" ? t.options.enableSubRowSelection(e) : (n = t.options.enableSubRowSelection) != null ? n : !0;
    }, e.getCanMultiSelect = () => {
      var n;
      return typeof t.options.enableMultiRowSelection == "function" ? t.options.enableMultiRowSelection(e) : (n = t.options.enableMultiRowSelection) != null ? n : !0;
    }, e.getToggleSelectedHandler = () => {
      const n = e.getCanSelect();
      return (o) => {
        var r;
        n && e.toggleSelected((r = o.target) == null ? void 0 : r.checked);
      };
    };
  }
}, q = (e, t, n, o, r) => {
  var i;
  const l = r.getRow(t, !0);
  n ? (l.getCanMultiSelect() || Object.keys(e).forEach((u) => delete e[u]), l.getCanSelect() && (e[t] = !0)) : delete e[t], o && (i = l.subRows) != null && i.length && l.getCanSelectSubRows() && l.subRows.forEach((u) => q(e, u.id, n, o, r));
};
function k(e, t) {
  const n = e.getState().rowSelection, o = [], r = {}, i = function(l, u) {
    return l.map((g) => {
      var a;
      const s = X(g, n);
      if (s && (o.push(g), r[g.id] = g), (a = g.subRows) != null && a.length && (g = {
        ...g,
        subRows: i(g.subRows)
      }), s)
        return g;
    }).filter(Boolean);
  };
  return {
    rows: i(t.rows),
    flatRows: o,
    rowsById: r
  };
}
function X(e, t) {
  var n;
  return (n = t[e.id]) != null ? n : !1;
}
function T(e, t, n) {
  var o;
  if (!((o = e.subRows) != null && o.length))
    return !1;
  let r = !0, i = !1;
  return e.subRows.forEach((l) => {
    if (!(i && !r) && (l.getCanSelect() && (X(l, t) ? i = !0 : r = !1), l.subRows && l.subRows.length)) {
      const u = T(l, t);
      u === "all" ? i = !0 : (u === "some" && (i = !0), r = !1);
    }
  }), r ? "all" : i ? "some" : !1;
}
const U = /([0-9]+)/gm, Ne = (e, t, n) => ge(A(e.getValue(n)).toLowerCase(), A(t.getValue(n)).toLowerCase()), Oe = (e, t, n) => ge(A(e.getValue(n)), A(t.getValue(n))), Ge = (e, t, n) => K(A(e.getValue(n)).toLowerCase(), A(t.getValue(n)).toLowerCase()), Le = (e, t, n) => K(A(e.getValue(n)), A(t.getValue(n))), ze = (e, t, n) => {
  const o = e.getValue(n), r = t.getValue(n);
  return o > r ? 1 : o < r ? -1 : 0;
}, ke = (e, t, n) => K(e.getValue(n), t.getValue(n));
function K(e, t) {
  return e === t ? 0 : e > t ? 1 : -1;
}
function A(e) {
  return typeof e == "number" ? isNaN(e) || e === 1 / 0 || e === -1 / 0 ? "" : String(e) : typeof e == "string" ? e : "";
}
function ge(e, t) {
  const n = e.split(U).filter(Boolean), o = t.split(U).filter(Boolean);
  for (; n.length && o.length; ) {
    const r = n.shift(), i = o.shift(), l = parseInt(r, 10), u = parseInt(i, 10), g = [l, u].sort();
    if (isNaN(g[0])) {
      if (r > i)
        return 1;
      if (i > r)
        return -1;
      continue;
    }
    if (isNaN(g[1]))
      return isNaN(l) ? -1 : 1;
    if (l > u)
      return 1;
    if (u > l)
      return -1;
  }
  return n.length - o.length;
}
const M = {
  alphanumeric: Ne,
  alphanumericCaseSensitive: Oe,
  text: Ge,
  textCaseSensitive: Le,
  datetime: ze,
  basic: ke
}, Be = {
  getInitialState: (e) => ({
    sorting: [],
    ...e
  }),
  getDefaultColumnDef: () => ({
    sortingFn: "auto",
    sortUndefined: 1
  }),
  getDefaultOptions: (e) => ({
    onSortingChange: _("sorting", e),
    isMultiSortEvent: (t) => t.shiftKey
  }),
  createColumn: (e, t) => {
    e.getAutoSortingFn = () => {
      const n = t.getFilteredRowModel().flatRows.slice(10);
      let o = !1;
      for (const r of n) {
        const i = r == null ? void 0 : r.getValue(e.id);
        if (Object.prototype.toString.call(i) === "[object Date]")
          return M.datetime;
        if (typeof i == "string" && (o = !0, i.split(U).length > 1))
          return M.alphanumeric;
      }
      return o ? M.text : M.basic;
    }, e.getAutoSortDir = () => {
      const n = t.getFilteredRowModel().flatRows[0];
      return typeof (n == null ? void 0 : n.getValue(e.id)) == "string" ? "asc" : "desc";
    }, e.getSortingFn = () => {
      var n, o;
      if (!e)
        throw new Error();
      return D(e.columnDef.sortingFn) ? e.columnDef.sortingFn : e.columnDef.sortingFn === "auto" ? e.getAutoSortingFn() : (n = (o = t.options.sortingFns) == null ? void 0 : o[e.columnDef.sortingFn]) != null ? n : M[e.columnDef.sortingFn];
    }, e.toggleSorting = (n, o) => {
      const r = e.getNextSortingOrder(), i = typeof n < "u" && n !== null;
      t.setSorting((l) => {
        const u = l == null ? void 0 : l.find((p) => p.id === e.id), g = l == null ? void 0 : l.findIndex((p) => p.id === e.id);
        let a = [], s, d = i ? n : r === "desc";
        if (l != null && l.length && e.getCanMultiSort() && o ? u ? s = "toggle" : s = "add" : l != null && l.length && g !== l.length - 1 ? s = "replace" : u ? s = "toggle" : s = "replace", s === "toggle" && (i || r || (s = "remove")), s === "add") {
          var c;
          a = [...l, {
            id: e.id,
            desc: d
          }], a.splice(0, a.length - ((c = t.options.maxMultiSortColCount) != null ? c : Number.MAX_SAFE_INTEGER));
        } else
          s === "toggle" ? a = l.map((p) => p.id === e.id ? {
            ...p,
            desc: d
          } : p) : s === "remove" ? a = l.filter((p) => p.id !== e.id) : a = [{
            id: e.id,
            desc: d
          }];
        return a;
      });
    }, e.getFirstSortDir = () => {
      var n, o;
      return ((n = (o = e.columnDef.sortDescFirst) != null ? o : t.options.sortDescFirst) != null ? n : e.getAutoSortDir() === "desc") ? "desc" : "asc";
    }, e.getNextSortingOrder = (n) => {
      var o, r;
      const i = e.getFirstSortDir(), l = e.getIsSorted();
      return l ? l !== i && ((o = t.options.enableSortingRemoval) == null || o) && // If enableSortRemove, enable in general
      (!(n && (r = t.options.enableMultiRemove) != null) || r) ? !1 : l === "desc" ? "asc" : "desc" : i;
    }, e.getCanSort = () => {
      var n, o;
      return ((n = e.columnDef.enableSorting) != null ? n : !0) && ((o = t.options.enableSorting) != null ? o : !0) && !!e.accessorFn;
    }, e.getCanMultiSort = () => {
      var n, o;
      return (n = (o = e.columnDef.enableMultiSort) != null ? o : t.options.enableMultiSort) != null ? n : !!e.accessorFn;
    }, e.getIsSorted = () => {
      var n;
      const o = (n = t.getState().sorting) == null ? void 0 : n.find((r) => r.id === e.id);
      return o ? o.desc ? "desc" : "asc" : !1;
    }, e.getSortIndex = () => {
      var n, o;
      return (n = (o = t.getState().sorting) == null ? void 0 : o.findIndex((r) => r.id === e.id)) != null ? n : -1;
    }, e.clearSorting = () => {
      t.setSorting((n) => n != null && n.length ? n.filter((o) => o.id !== e.id) : []);
    }, e.getToggleSortingHandler = () => {
      const n = e.getCanSort();
      return (o) => {
        n && (o.persist == null || o.persist(), e.toggleSorting == null || e.toggleSorting(void 0, e.getCanMultiSort() ? t.options.isMultiSortEvent == null ? void 0 : t.options.isMultiSortEvent(o) : !1));
      };
    };
  },
  createTable: (e) => {
    e.setSorting = (t) => e.options.onSortingChange == null ? void 0 : e.options.onSortingChange(t), e.resetSorting = (t) => {
      var n, o;
      e.setSorting(t ? [] : (n = (o = e.initialState) == null ? void 0 : o.sorting) != null ? n : []);
    }, e.getPreSortedRowModel = () => e.getGroupedRowModel(), e.getSortedRowModel = () => (!e._getSortedRowModel && e.options.getSortedRowModel && (e._getSortedRowModel = e.options.getSortedRowModel(e)), e.options.manualSorting || !e._getSortedRowModel ? e.getPreSortedRowModel() : e._getSortedRowModel());
  }
}, be = {
  getInitialState: (e) => ({
    columnVisibility: {},
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnVisibilityChange: _("columnVisibility", e)
  }),
  createColumn: (e, t) => {
    e.toggleVisibility = (n) => {
      e.getCanHide() && t.setColumnVisibility((o) => ({
        ...o,
        [e.id]: n ?? !e.getIsVisible()
      }));
    }, e.getIsVisible = () => {
      var n, o;
      return (n = (o = t.getState().columnVisibility) == null ? void 0 : o[e.id]) != null ? n : !0;
    }, e.getCanHide = () => {
      var n, o;
      return ((n = e.columnDef.enableHiding) != null ? n : !0) && ((o = t.options.enableHiding) != null ? o : !0);
    }, e.getToggleVisibilityHandler = () => (n) => {
      e.toggleVisibility == null || e.toggleVisibility(n.target.checked);
    };
  },
  createRow: (e, t) => {
    e._getAllVisibleCells = S(() => [e.getAllCells(), t.getState().columnVisibility], (n) => n.filter((o) => o.column.getIsVisible()), {
      key: process.env.NODE_ENV === "production" && "row._getAllVisibleCells",
      debug: () => {
        var n;
        return (n = t.options.debugAll) != null ? n : t.options.debugRows;
      }
    }), e.getVisibleCells = S(() => [e.getLeftVisibleCells(), e.getCenterVisibleCells(), e.getRightVisibleCells()], (n, o, r) => [...n, ...o, ...r], {
      key: process.env.NODE_ENV === "development" && "row.getVisibleCells",
      debug: () => {
        var n;
        return (n = t.options.debugAll) != null ? n : t.options.debugRows;
      }
    });
  },
  createTable: (e) => {
    const t = (n, o) => S(() => [o(), o().filter((r) => r.getIsVisible()).map((r) => r.id).join("_")], (r) => r.filter((i) => i.getIsVisible == null ? void 0 : i.getIsVisible()), {
      key: n,
      debug: () => {
        var r;
        return (r = e.options.debugAll) != null ? r : e.options.debugColumns;
      }
    });
    e.getVisibleFlatColumns = t("getVisibleFlatColumns", () => e.getAllFlatColumns()), e.getVisibleLeafColumns = t("getVisibleLeafColumns", () => e.getAllLeafColumns()), e.getLeftVisibleLeafColumns = t("getLeftVisibleLeafColumns", () => e.getLeftLeafColumns()), e.getRightVisibleLeafColumns = t("getRightVisibleLeafColumns", () => e.getRightLeafColumns()), e.getCenterVisibleLeafColumns = t("getCenterVisibleLeafColumns", () => e.getCenterLeafColumns()), e.setColumnVisibility = (n) => e.options.onColumnVisibilityChange == null ? void 0 : e.options.onColumnVisibilityChange(n), e.resetColumnVisibility = (n) => {
      var o;
      e.setColumnVisibility(n ? {} : (o = e.initialState.columnVisibility) != null ? o : {});
    }, e.toggleAllColumnsVisible = (n) => {
      var o;
      n = (o = n) != null ? o : !e.getIsAllColumnsVisible(), e.setColumnVisibility(e.getAllLeafColumns().reduce((r, i) => ({
        ...r,
        [i.id]: n || !(i.getCanHide != null && i.getCanHide())
      }), {}));
    }, e.getIsAllColumnsVisible = () => !e.getAllLeafColumns().some((n) => !(n.getIsVisible != null && n.getIsVisible())), e.getIsSomeColumnsVisible = () => e.getAllLeafColumns().some((n) => n.getIsVisible == null ? void 0 : n.getIsVisible()), e.getToggleAllColumnsVisibilityHandler = () => (n) => {
      var o;
      e.toggleAllColumnsVisible((o = n.target) == null ? void 0 : o.checked);
    };
  }
}, ee = [Se, be, ye, Ie, Re, Be, Pe, Ce, De, He, me];
function je(e) {
  var t;
  (e.debugAll || e.debugTable) && console.info("Creating Table Instance...");
  let n = {
    _features: ee
  };
  const o = n._features.reduce((s, d) => Object.assign(s, d.getDefaultOptions == null ? void 0 : d.getDefaultOptions(n)), {}), r = (s) => n.options.mergeOptions ? n.options.mergeOptions(o, s) : {
    ...o,
    ...s
  };
  let l = {
    ...{},
    ...(t = e.initialState) != null ? t : {}
  };
  n._features.forEach((s) => {
    var d;
    l = (d = s.getInitialState == null ? void 0 : s.getInitialState(l)) != null ? d : l;
  });
  const u = [];
  let g = !1;
  const a = {
    _features: ee,
    options: {
      ...o,
      ...e
    },
    initialState: l,
    _queue: (s) => {
      u.push(s), g || (g = !0, Promise.resolve().then(() => {
        for (; u.length; )
          u.shift()();
        g = !1;
      }).catch((d) => setTimeout(() => {
        throw d;
      })));
    },
    reset: () => {
      n.setState(n.initialState);
    },
    setOptions: (s) => {
      const d = E(s, n.options);
      n.options = r(d);
    },
    getState: () => n.options.state,
    setState: (s) => {
      n.options.onStateChange == null || n.options.onStateChange(s);
    },
    _getRowId: (s, d, c) => {
      var p;
      return (p = n.options.getRowId == null ? void 0 : n.options.getRowId(s, d, c)) != null ? p : `${c ? [c.id, d].join(".") : d}`;
    },
    getCoreRowModel: () => (n._getCoreRowModel || (n._getCoreRowModel = n.options.getCoreRowModel(n)), n._getCoreRowModel()),
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => n.getPaginationRowModel(),
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (s, d) => {
      let c = (d ? n.getPrePaginationRowModel() : n.getRowModel()).rowsById[s];
      if (!c && (c = n.getCoreRowModel().rowsById[s], !c))
        throw process.env.NODE_ENV !== "production" ? new Error(`getRow could not find row with ID: ${s}`) : new Error();
      return c;
    },
    _getDefaultColumnDef: S(() => [n.options.defaultColumn], (s) => {
      var d;
      return s = (d = s) != null ? d : {}, {
        header: (c) => {
          const p = c.header.column.columnDef;
          return p.accessorKey ? p.accessorKey : p.accessorFn ? p.id : null;
        },
        // footer: props => props.header.column.id,
        cell: (c) => {
          var p, f;
          return (p = (f = c.renderValue()) == null || f.toString == null ? void 0 : f.toString()) != null ? p : null;
        },
        ...n._features.reduce((c, p) => Object.assign(c, p.getDefaultColumnDef == null ? void 0 : p.getDefaultColumnDef()), {}),
        ...s
      };
    }, {
      debug: () => {
        var s;
        return (s = n.options.debugAll) != null ? s : n.options.debugColumns;
      },
      key: process.env.NODE_ENV === "development" && "getDefaultColumnDef"
    }),
    _getColumnDefs: () => n.options.columns,
    getAllColumns: S(() => [n._getColumnDefs()], (s) => {
      const d = function(c, p, f) {
        return f === void 0 && (f = 0), c.map((m) => {
          const C = fe(n, m, f, p), v = m;
          return C.columns = v.columns ? d(v.columns, C, f + 1) : [], C;
        });
      };
      return d(s);
    }, {
      key: process.env.NODE_ENV === "development" && "getAllColumns",
      debug: () => {
        var s;
        return (s = n.options.debugAll) != null ? s : n.options.debugColumns;
      }
    }),
    getAllFlatColumns: S(() => [n.getAllColumns()], (s) => s.flatMap((d) => d.getFlatColumns()), {
      key: process.env.NODE_ENV === "development" && "getAllFlatColumns",
      debug: () => {
        var s;
        return (s = n.options.debugAll) != null ? s : n.options.debugColumns;
      }
    }),
    _getAllFlatColumnsById: S(() => [n.getAllFlatColumns()], (s) => s.reduce((d, c) => (d[c.id] = c, d), {}), {
      key: process.env.NODE_ENV === "development" && "getAllFlatColumnsById",
      debug: () => {
        var s;
        return (s = n.options.debugAll) != null ? s : n.options.debugColumns;
      }
    }),
    getAllLeafColumns: S(() => [n.getAllColumns(), n._getOrderColumnsFn()], (s, d) => {
      let c = s.flatMap((p) => p.getLeafColumns());
      return d(c);
    }, {
      key: process.env.NODE_ENV === "development" && "getAllLeafColumns",
      debug: () => {
        var s;
        return (s = n.options.debugAll) != null ? s : n.options.debugColumns;
      }
    }),
    getColumn: (s) => {
      const d = n._getAllFlatColumnsById()[s];
      return process.env.NODE_ENV !== "production" && !d && console.error(`[Table] Column with id '${s}' does not exist.`), d;
    }
  };
  Object.assign(n, a);
  for (let s = 0; s < n._features.length; s++) {
    const d = n._features[s];
    d == null || d.createTable == null || d.createTable(n);
  }
  return n;
}
function qe(e, t, n, o) {
  const r = () => {
    var l;
    return (l = i.getValue()) != null ? l : e.options.renderFallbackValue;
  }, i = {
    id: `${t.id}_${n.id}`,
    row: t,
    column: n,
    getValue: () => t.getValue(o),
    renderValue: r,
    getContext: S(() => [e, n, t, i], (l, u, g, a) => ({
      table: l,
      column: u,
      row: g,
      cell: a,
      getValue: a.getValue,
      renderValue: a.renderValue
    }), {
      key: process.env.NODE_ENV === "development" && "cell.getContext",
      debug: () => e.options.debugAll
    })
  };
  return e._features.forEach((l) => {
    l.createCell == null || l.createCell(i, n, t, e);
  }, {}), i;
}
const Te = (e, t, n, o, r, i, l) => {
  let u = {
    id: t,
    index: o,
    original: n,
    depth: r,
    parentId: l,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (g) => {
      if (u._valuesCache.hasOwnProperty(g))
        return u._valuesCache[g];
      const a = e.getColumn(g);
      if (a != null && a.accessorFn)
        return u._valuesCache[g] = a.accessorFn(u.original, o), u._valuesCache[g];
    },
    getUniqueValues: (g) => {
      if (u._uniqueValuesCache.hasOwnProperty(g))
        return u._uniqueValuesCache[g];
      const a = e.getColumn(g);
      if (a != null && a.accessorFn)
        return a.columnDef.getUniqueValues ? (u._uniqueValuesCache[g] = a.columnDef.getUniqueValues(u.original, o), u._uniqueValuesCache[g]) : (u._uniqueValuesCache[g] = [u.getValue(g)], u._uniqueValuesCache[g]);
    },
    renderValue: (g) => {
      var a;
      return (a = u.getValue(g)) != null ? a : e.options.renderFallbackValue;
    },
    subRows: i ?? [],
    getLeafRows: () => ce(u.subRows, (g) => g.subRows),
    getParentRow: () => u.parentId ? e.getRow(u.parentId, !0) : void 0,
    getParentRows: () => {
      let g = [], a = u;
      for (; ; ) {
        const s = a.getParentRow();
        if (!s)
          break;
        g.push(s), a = s;
      }
      return g.reverse();
    },
    getAllCells: S(() => [e.getAllLeafColumns()], (g) => g.map((a) => qe(e, u, a, a.id)), {
      key: process.env.NODE_ENV === "development" && "row.getAllCells",
      debug: () => {
        var g;
        return (g = e.options.debugAll) != null ? g : e.options.debugRows;
      }
    }),
    _getAllCellsByColumnId: S(() => [u.getAllCells()], (g) => g.reduce((a, s) => (a[s.column.id] = s, a), {}), {
      key: process.env.NODE_ENV === "production" && "row.getAllCellsByColumnId",
      debug: () => {
        var g;
        return (g = e.options.debugAll) != null ? g : e.options.debugRows;
      }
    })
  };
  for (let g = 0; g < e._features.length; g++) {
    const a = e._features[g];
    a == null || a.createRow == null || a.createRow(u, e);
  }
  return u;
};
function Xe() {
  return (e) => S(() => [e.options.data], (t) => {
    const n = {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, o = function(r, i, l) {
      i === void 0 && (i = 0);
      const u = [];
      for (let a = 0; a < r.length; a++) {
        const s = Te(e, e._getRowId(r[a], a, l), r[a], a, i, void 0, l == null ? void 0 : l.id);
        if (n.flatRows.push(s), n.rowsById[s.id] = s, u.push(s), e.options.getSubRows) {
          var g;
          s.originalSubRows = e.options.getSubRows(r[a], a), (g = s.originalSubRows) != null && g.length && (s.subRows = o(s.originalSubRows, i + 1, s));
        }
      }
      return u;
    };
    return n.rows = o(t), n;
  }, {
    key: process.env.NODE_ENV === "development" && "getRowModel",
    debug: () => {
      var t;
      return (t = e.options.debugAll) != null ? t : e.options.debugTable;
    },
    onChange: () => {
      e._autoResetPageIndex();
    }
  });
}
function Ke() {
  return (e) => S(() => [e.getState().sorting, e.getPreSortedRowModel()], (t, n) => {
    if (!n.rows.length || !(t != null && t.length))
      return n;
    const o = e.getState().sorting, r = [], i = o.filter((g) => {
      var a;
      return (a = e.getColumn(g.id)) == null ? void 0 : a.getCanSort();
    }), l = {};
    i.forEach((g) => {
      const a = e.getColumn(g.id);
      a && (l[g.id] = {
        sortUndefined: a.columnDef.sortUndefined,
        invertSorting: a.columnDef.invertSorting,
        sortingFn: a.getSortingFn()
      });
    });
    const u = (g) => {
      const a = g.map((s) => ({
        ...s
      }));
      return a.sort((s, d) => {
        for (let p = 0; p < i.length; p += 1) {
          var c;
          const f = i[p], m = l[f.id], C = (c = f == null ? void 0 : f.desc) != null ? c : !1;
          let v = 0;
          if (m.sortUndefined) {
            const w = s.getValue(f.id), R = d.getValue(f.id), h = w === void 0, F = R === void 0;
            (h || F) && (v = h && F ? 0 : h ? m.sortUndefined : -m.sortUndefined);
          }
          if (v === 0 && (v = m.sortingFn(s, d, f.id)), v !== 0)
            return C && (v *= -1), m.invertSorting && (v *= -1), v;
        }
        return s.index - d.index;
      }), a.forEach((s) => {
        var d;
        r.push(s), (d = s.subRows) != null && d.length && (s.subRows = u(s.subRows));
      }), a;
    };
    return {
      rows: u(n.rows),
      flatRows: r,
      rowsById: n.rowsById
    };
  }, {
    key: process.env.NODE_ENV === "development" && "getSortedRowModel",
    debug: () => {
      var t;
      return (t = e.options.debugAll) != null ? t : e.options.debugTable;
    },
    onChange: () => {
      e._autoResetPageIndex();
    }
  });
}
function Ue(e) {
  const t = [], n = (o) => {
    var r;
    t.push(o), (r = o.subRows) != null && r.length && o.getIsExpanded() && o.subRows.forEach(n);
  };
  return e.rows.forEach(n), {
    rows: t,
    flatRows: e.flatRows,
    rowsById: e.rowsById
  };
}
function Je(e) {
  return (t) => S(() => [t.getState().pagination, t.getPrePaginationRowModel(), t.options.paginateExpandedRows ? void 0 : t.getState().expanded], (n, o) => {
    if (!o.rows.length)
      return o;
    const {
      pageSize: r,
      pageIndex: i
    } = n;
    let {
      rows: l,
      flatRows: u,
      rowsById: g
    } = o;
    const a = r * i, s = a + r;
    l = l.slice(a, s);
    let d;
    t.options.paginateExpandedRows ? d = {
      rows: l,
      flatRows: u,
      rowsById: g
    } : d = Ue({
      rows: l,
      flatRows: u,
      rowsById: g
    }), d.flatRows = [];
    const c = (p) => {
      d.flatRows.push(p), p.subRows.length && p.subRows.forEach(c);
    };
    return d.rows.forEach(c), d;
  }, {
    key: process.env.NODE_ENV === "development" && "getPaginationRowModel",
    debug: () => {
      var n;
      return (n = t.options.debugAll) != null ? n : t.options.debugTable;
    }
  });
}
export {
  me as ColumnSizing,
  Ce as Expanding,
  Re as Filters,
  Pe as Grouping,
  Se as Headers,
  ye as Ordering,
  De as Pagination,
  Ie as Pinning,
  He as RowSelection,
  Be as Sorting,
  be as Visibility,
  O as aggregationFns,
  P as buildHeaderGroups,
  qe as createCell,
  fe as createColumn,
  Te as createRow,
  je as createTable,
  x as defaultColumnSizing,
  Ue as expandRows,
  V as filterFns,
  ce as flattenBy,
  E as functionalUpdate,
  Xe as getCoreRowModel,
  Je as getPaginationRowModel,
  Ke as getSortedRowModel,
  D as isFunction,
  pe as isNumberArray,
  X as isRowSelected,
  T as isSubRowSelected,
  _ as makeStateUpdater,
  S as memo,
  xe as orderColumns,
  ve as passiveEventSupported,
  U as reSplitAlphaNumeric,
  k as selectRowsFn,
  Z as shouldAutoRemoveFilter,
  M as sortingFns
};
