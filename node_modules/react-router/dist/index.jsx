import { r as o } from "../../react/index.jsx";
import { UNSAFE_invariant as u, Action as A, parsePath as M, stripBasename as q, UNSAFE_warning as b, joinPaths as U, UNSAFE_getResolveToMatches as T, resolveTo as j, matchRoutes as X, isRouteErrorResponse as G } from "../../@remix-run/router/dist/router.jsx";
import { createPath as ye, matchPath as Re, resolvePath as Ce } from "../../@remix-run/router/dist/router.jsx";
/**
 * React Router v6.21.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function D() {
  return D = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, D.apply(this, arguments);
}
const V = /* @__PURE__ */ o.createContext(null);
process.env.NODE_ENV !== "production" && (V.displayName = "DataRouter");
const k = /* @__PURE__ */ o.createContext(null);
process.env.NODE_ENV !== "production" && (k.displayName = "DataRouterState");
const K = /* @__PURE__ */ o.createContext(null);
process.env.NODE_ENV !== "production" && (K.displayName = "Await");
const R = /* @__PURE__ */ o.createContext(null);
process.env.NODE_ENV !== "production" && (R.displayName = "Navigation");
const O = /* @__PURE__ */ o.createContext(null);
process.env.NODE_ENV !== "production" && (O.displayName = "Location");
const y = /* @__PURE__ */ o.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (y.displayName = "Route");
const w = /* @__PURE__ */ o.createContext(null);
process.env.NODE_ENV !== "production" && (w.displayName = "RouteError");
function he(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t;
  P() || (process.env.NODE_ENV !== "production" ? u(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : u(!1));
  let {
    basename: r,
    navigator: l
  } = o.useContext(R), {
    hash: s,
    pathname: a,
    search: f
  } = Z(e, {
    relative: n
  }), m = a;
  return r !== "/" && (m = a === "/" ? r : U([r, a])), l.createHref({
    pathname: m,
    search: f,
    hash: s
  });
}
function P() {
  return o.useContext(O) != null;
}
function B() {
  return P() || (process.env.NODE_ENV !== "production" ? u(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : u(!1)), o.useContext(O).location;
}
const J = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function W(e) {
  o.useContext(R).static || o.useLayoutEffect(e);
}
function fe() {
  let {
    isDataRoute: e
  } = o.useContext(y);
  return e ? ue() : Q();
}
function Q() {
  P() || (process.env.NODE_ENV !== "production" ? u(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : u(!1));
  let e = o.useContext(V), {
    basename: t,
    future: n,
    navigator: r
  } = o.useContext(R), {
    matches: l
  } = o.useContext(y), {
    pathname: s
  } = B(), a = JSON.stringify(T(l, n.v7_relativeSplatPath)), f = o.useRef(!1);
  return W(() => {
    f.current = !0;
  }), o.useCallback(function(p, c) {
    if (c === void 0 && (c = {}), process.env.NODE_ENV !== "production" && b(f.current, J), !f.current)
      return;
    if (typeof p == "number") {
      r.go(p);
      return;
    }
    let i = j(p, JSON.parse(a), s, c.relative === "path");
    e == null && t !== "/" && (i.pathname = i.pathname === "/" ? t : U([t, i.pathname])), (c.replace ? r.replace : r.push)(i, c.state, c);
  }, [t, r, a, s, e]);
}
function Z(e, t) {
  let {
    relative: n
  } = t === void 0 ? {} : t, {
    future: r
  } = o.useContext(R), {
    matches: l
  } = o.useContext(y), {
    pathname: s
  } = B(), a = JSON.stringify(T(l, r.v7_relativeSplatPath));
  return o.useMemo(() => j(e, JSON.parse(a), s, n === "path"), [e, a, s, n]);
}
function H(e, t) {
  return $(e, t);
}
function $(e, t, n, r) {
  P() || (process.env.NODE_ENV !== "production" ? u(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : u(!1));
  let {
    navigator: l
  } = o.useContext(R), {
    matches: s
  } = o.useContext(y), a = s[s.length - 1], f = a ? a.params : {}, m = a ? a.pathname : "/", p = a ? a.pathnameBase : "/", c = a && a.route;
  if (process.env.NODE_ENV !== "production") {
    let h = c && c.path || "";
    z(m, !c || h.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + m + '" (under <Route path="' + h + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + h + '"> to <Route ') + ('path="' + (h === "/" ? "*" : h + "/*") + '">.'));
  }
  let i = B(), d;
  if (t) {
    var E;
    let h = typeof t == "string" ? M(t) : t;
    p === "/" || (E = h.pathname) != null && E.startsWith(p) || (process.env.NODE_ENV !== "production" ? u(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + p + '" ') + ('but pathname "' + h.pathname + '" was given in the `location` prop.')) : u(!1)), d = h;
  } else
    d = i;
  let N = d.pathname || "/", g = p === "/" ? N : N.slice(p.length) || "/", v = X(e, {
    pathname: g
  });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && b(c || v != null, 'No routes matched location "' + d.pathname + d.search + d.hash + '" '), process.env.NODE_ENV !== "production" && b(v == null || v[v.length - 1].route.element !== void 0 || v[v.length - 1].route.Component !== void 0 || v[v.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + d.pathname + d.search + d.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let C = oe(v && v.map((h) => Object.assign({}, h, {
    params: Object.assign({}, f, h.params),
    pathname: U([
      p,
      // Re-encode pathnames that were decoded inside matchRoutes
      l.encodeLocation ? l.encodeLocation(h.pathname).pathname : h.pathname
    ]),
    pathnameBase: h.pathnameBase === "/" ? p : U([
      p,
      // Re-encode pathnames that were decoded inside matchRoutes
      l.encodeLocation ? l.encodeLocation(h.pathnameBase).pathname : h.pathnameBase
    ])
  })), s, n, r);
  return t && C ? /* @__PURE__ */ o.createElement(O.Provider, {
    value: {
      location: D({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, d),
      navigationType: A.Pop
    }
  }, C) : C;
}
function ee() {
  let e = se(), t = G(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", l = {
    padding: "0.5rem",
    backgroundColor: r
  }, s = {
    padding: "2px 4px",
    backgroundColor: r
  }, a = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", e), a = /* @__PURE__ */ o.createElement(o.Fragment, null, /* @__PURE__ */ o.createElement("p", null, "ðŸ’¿ Hey developer ðŸ‘‹"), /* @__PURE__ */ o.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ o.createElement("code", {
    style: s
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ o.createElement("code", {
    style: s
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ o.createElement(o.Fragment, null, /* @__PURE__ */ o.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ o.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, t), n ? /* @__PURE__ */ o.createElement("pre", {
    style: l
  }, n) : null, a);
}
const te = /* @__PURE__ */ o.createElement(ee, null);
class re extends o.Component {
  constructor(t) {
    super(t), this.state = {
      location: t.location,
      revalidation: t.revalidation,
      error: t.error
    };
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    };
  }
  static getDerivedStateFromProps(t, n) {
    return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
      error: t.error,
      location: t.location,
      revalidation: t.revalidation
    } : {
      error: t.error !== void 0 ? t.error : n.error,
      location: n.location,
      revalidation: t.revalidation || n.revalidation
    };
  }
  componentDidCatch(t, n) {
    console.error("React Router caught the following error during render", t, n);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ o.createElement(y.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ o.createElement(w.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function ne(e) {
  let {
    routeContext: t,
    match: n,
    children: r
  } = e, l = o.useContext(V);
  return l && l.static && l.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (l.staticContext._deepestRenderedBoundaryId = n.route.id), /* @__PURE__ */ o.createElement(y.Provider, {
    value: t
  }, r);
}
function oe(e, t, n, r) {
  var l;
  if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) {
    var s;
    if ((s = n) != null && s.errors)
      e = n.matches;
    else
      return null;
  }
  let a = e, f = (l = n) == null ? void 0 : l.errors;
  if (f != null) {
    let c = a.findIndex((i) => i.route.id && (f == null ? void 0 : f[i.route.id]));
    c >= 0 || (process.env.NODE_ENV !== "production" ? u(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(f).join(",")) : u(!1)), a = a.slice(0, Math.min(a.length, c + 1));
  }
  let m = !1, p = -1;
  if (n && r && r.v7_partialHydration)
    for (let c = 0; c < a.length; c++) {
      let i = a[c];
      if ((i.route.HydrateFallback || i.route.hydrateFallbackElement) && (p = c), i.route.id) {
        let {
          loaderData: d,
          errors: E
        } = n, N = i.route.loader && d[i.route.id] === void 0 && (!E || E[i.route.id] === void 0);
        if (i.route.lazy || N) {
          m = !0, p >= 0 ? a = a.slice(0, p + 1) : a = [a[0]];
          break;
        }
      }
    }
  return a.reduceRight((c, i, d) => {
    let E, N = !1, g = null, v = null;
    n && (E = f && i.route.id ? f[i.route.id] : void 0, g = i.route.errorElement || te, m && (p < 0 && d === 0 ? (z("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), N = !0, v = null) : p === d && (N = !0, v = i.route.hydrateFallbackElement || null)));
    let C = t.concat(a.slice(0, d + 1)), h = () => {
      let x;
      return E ? x = g : N ? x = v : i.route.Component ? x = /* @__PURE__ */ o.createElement(i.route.Component, null) : i.route.element ? x = i.route.element : x = c, /* @__PURE__ */ o.createElement(ne, {
        match: i,
        routeContext: {
          outlet: c,
          matches: C,
          isDataRoute: n != null
        },
        children: x
      });
    };
    return n && (i.route.ErrorBoundary || i.route.errorElement || d === 0) ? /* @__PURE__ */ o.createElement(re, {
      location: n.location,
      revalidation: n.revalidation,
      component: g,
      error: E,
      children: h(),
      routeContext: {
        outlet: null,
        matches: C,
        isDataRoute: !0
      }
    }) : h();
  }, null);
}
var Y = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e;
}(Y || {}), _ = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e;
}(_ || {});
function I(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function ae(e) {
  let t = o.useContext(V);
  return t || (process.env.NODE_ENV !== "production" ? u(!1, I(e)) : u(!1)), t;
}
function ie(e) {
  let t = o.useContext(k);
  return t || (process.env.NODE_ENV !== "production" ? u(!1, I(e)) : u(!1)), t;
}
function le(e) {
  let t = o.useContext(y);
  return t || (process.env.NODE_ENV !== "production" ? u(!1, I(e)) : u(!1)), t;
}
function L(e) {
  let t = le(e), n = t.matches[t.matches.length - 1];
  return n.route.id || (process.env.NODE_ENV !== "production" ? u(!1, e + ' can only be used on routes that contain a unique "id"') : u(!1)), n.route.id;
}
function ve() {
  return L(_.UseRouteId);
}
function se() {
  var e;
  let t = o.useContext(w), n = ie(_.UseRouteError), r = L(_.UseRouteError);
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r];
}
function ue() {
  let {
    router: e
  } = ae(Y.UseNavigateStable), t = L(_.UseNavigateStable), n = o.useRef(!1);
  return W(() => {
    n.current = !0;
  }), o.useCallback(function(l, s) {
    s === void 0 && (s = {}), process.env.NODE_ENV !== "production" && b(n.current, J), n.current && (typeof l == "number" ? e.navigate(l) : e.navigate(l, D({
      fromRouteId: t
    }, s)));
  }, [e, t]);
}
const S = {};
function z(e, t, n) {
  !t && !S[e] && (S[e] = !0, process.env.NODE_ENV !== "production" && b(!1, n));
}
function ce(e) {
  process.env.NODE_ENV !== "production" ? u(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : u(!1);
}
function me(e) {
  let {
    basename: t = "/",
    children: n = null,
    location: r,
    navigationType: l = A.Pop,
    navigator: s,
    static: a = !1,
    future: f
  } = e;
  P() && (process.env.NODE_ENV !== "production" ? u(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : u(!1));
  let m = t.replace(/^\/*/, "/"), p = o.useMemo(() => ({
    basename: m,
    navigator: s,
    static: a,
    future: D({
      v7_relativeSplatPath: !1
    }, f)
  }), [m, f, s, a]);
  typeof r == "string" && (r = M(r));
  let {
    pathname: c = "/",
    search: i = "",
    hash: d = "",
    state: E = null,
    key: N = "default"
  } = r, g = o.useMemo(() => {
    let v = q(c, m);
    return v == null ? null : {
      location: {
        pathname: v,
        search: i,
        hash: d,
        state: E,
        key: N
      },
      navigationType: l
    };
  }, [m, c, i, d, E, N, l]);
  return process.env.NODE_ENV !== "production" && b(g != null, '<Router basename="' + m + '"> is not able to match the URL ' + ('"' + c + i + d + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), g == null ? null : /* @__PURE__ */ o.createElement(R.Provider, {
    value: p
  }, /* @__PURE__ */ o.createElement(O.Provider, {
    children: n,
    value: g
  }));
}
function Ee(e) {
  let {
    children: t,
    location: n
  } = e;
  return H(F(t), n);
}
new Promise(() => {
});
function F(e, t) {
  t === void 0 && (t = []);
  let n = [];
  return o.Children.forEach(e, (r, l) => {
    if (!/* @__PURE__ */ o.isValidElement(r))
      return;
    let s = [...t, l];
    if (r.type === o.Fragment) {
      n.push.apply(n, F(r.props.children, s));
      return;
    }
    r.type !== ce && (process.env.NODE_ENV !== "production" ? u(!1, "[" + (typeof r.type == "string" ? r.type : r.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : u(!1)), !r.props.index || !r.props.children || (process.env.NODE_ENV !== "production" ? u(!1, "An index route cannot have child routes.") : u(!1));
    let a = {
      id: r.props.id || s.join("-"),
      caseSensitive: r.props.caseSensitive,
      element: r.props.element,
      Component: r.props.Component,
      index: r.props.index,
      path: r.props.path,
      loader: r.props.loader,
      action: r.props.action,
      errorElement: r.props.errorElement,
      ErrorBoundary: r.props.ErrorBoundary,
      hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
      shouldRevalidate: r.props.shouldRevalidate,
      handle: r.props.handle,
      lazy: r.props.lazy
    };
    r.props.children && (a.children = F(r.props.children, s)), n.push(a);
  }), n;
}
export {
  A as NavigationType,
  ce as Route,
  me as Router,
  Ee as Routes,
  V as UNSAFE_DataRouterContext,
  k as UNSAFE_DataRouterStateContext,
  O as UNSAFE_LocationContext,
  R as UNSAFE_NavigationContext,
  y as UNSAFE_RouteContext,
  ve as UNSAFE_useRouteId,
  $ as UNSAFE_useRoutesImpl,
  ye as createPath,
  F as createRoutesFromChildren,
  F as createRoutesFromElements,
  G as isRouteErrorResponse,
  Re as matchPath,
  X as matchRoutes,
  M as parsePath,
  Ce as resolvePath,
  he as useHref,
  P as useInRouterContext,
  B as useLocation,
  fe as useNavigate,
  Z as useResolvedPath,
  se as useRouteError,
  H as useRoutes
};
